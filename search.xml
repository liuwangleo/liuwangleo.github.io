<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/03/13/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/03/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用排序算法汇总比较"><a href="#常用排序算法汇总比较" class="headerlink" title="常用排序算法汇总比较"></a>常用排序算法汇总比较</h1><table border="1">
    <tr>
      <th>分类</th>
      <th>类型</th>  
      <th>方法</th>
      <th>时间复杂度(平均)</th>
      <th>时间复杂度(最坏)</th>
      <th>时间复杂度(最好)</th>
      <th>空间复杂度</th>
      <th>稳定性</th>
    </tr >
    <tr>
        <td rowspan="8" style="text-align:center;vertical-align: middle;">比较类</td>
        <td rowspan="2" style="text-align:center;vertical-align: middle;">交换排序</td>
        <td>冒泡排序</td>
       <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>稳定</td>
    </tr>
    <tr>
        <td>快速排序</td>
        <td>O(nlog2n)</td>
          <td>O(n²)</td>
          <td>O(nlog2n)</td>
          <td>O(nlog2n)</td>
          <td>不稳定</td>
    </tr>
    <tr>
        <td rowspan="2" style="text-align:center;vertical-align: middle;">插入排序</td>
        <td>简单插入排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>稳定</td>
    </tr>
    <tr>
        <td>希尔排序</td>
        <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(1)</td>
          <td>不稳定</td>
    </tr>
   <tr>
        <td rowspan="2" style="text-align:center;vertical-align: middle;">选择排序</td>
        <td>选择排序</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(n²)</td>
          <td>O(1)</td>
          <td>不稳定</td>
    </tr>
  <tr>
        <td>堆排序</td>
        <td>O(nlog2n)</td>
          <td>O(nlog2n)</td>
          <td>O(nlog2n)</td>
          <td>O(1)</td>
          <td>不稳定</td>
    </tr>
  <tr>
        <td rowspan="2" style="text-align:center;vertical-align: middle;">归并排序</td>
        <td>两路归并排序</td>
          <td>O(nlog2n)</td>
          <td>O(nlog2n)</td>
          <td>O(nlog2n)</td>
          <td>O(n)</td>
          <td>稳定</td>
    </tr>
  <tr>
        <td>多路归并排序</td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
          <td></td>
    </tr>
  <tr>
        <td rowspan="3" style="text-align:center;vertical-align: middle;">非比较类</td>
        <td>计数排序</td>
         <td rowspan="3" style="text-align:center;vertical-align: middle;"></td>
         <td>O(n+k)</td>
          <td>O(n+k)</td>
          <td>O(n+k)</td>
          <td>O(n+k)</td>
          <td>稳定</td>
    </tr>
  <tr>
        <td>桶排序</td>
         <td>O(n+k)</td>
          <td>O(n²)</td>
          <td>O(n)</td>
          <td>O(n+k)</td>
          <td>稳定</td>
    </tr>
  <tr>
        <td>基数排序</td>
         <td>O(n*k)</td>
          <td>O(n*k)</td>
          <td>O(n*k)</td>
          <td>O(n+k)</td>
          <td>稳定</td>
    </tr>
</table>

<blockquote>
<p>给大家推荐一个网站，理解常用排序算法的执行过程 <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们两个</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<p><strong>注意:我们知道冒泡排序有一个缺点，就是无论数据是否已排序完成，都固定会执行n(n-1)/2次。可以设计一个程序，使用岗哨的概念，提前中断程序，以此提高程序执行效率</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort1</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        flag = <span class="number">0</span>  <span class="comment"># 判断是否执行了交换操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<h2 id="算法理解-1"><a href="#算法理解-1" class="headerlink" title="算法理解"></a>算法理解</h2><ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= <span class="number">2</span>:</span><br><span class="line">        mid = data[<span class="built_in">len</span>(data) // <span class="number">2</span>]</span><br><span class="line">        left, right = [], []</span><br><span class="line">        data.remove(mid)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= mid:</span><br><span class="line">                right.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(num)</span><br><span class="line">        <span class="keyword">return</span> quick_sort(left) + [mid] + quick_sort(right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(quickSort([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">12</span>]))</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 一点小建议 可以在纸上画一下整个执行流程 便于理解  <a href="https://img-blog.csdnimg.cn/20190331172055940.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI1MDYyMw==,size_16,color_FFFFFF,t_70">参考这里</a>。我总觉的自己实现的代码有点问题，如果有好的建议可以去<a href="https://blog.csdn.net/qq_36581961/article/details/111350029">CSDN-这篇博客</a>留言。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一行代码实现</span></span><br><span class="line">quick_sort = <span class="keyword">lambda</span> array: array <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span> <span class="keyword">else</span> quick_sort(</span><br><span class="line">    [item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &lt;= array[<span class="number">0</span>]]) + [array[<span class="number">0</span>]] + quick_sort(</span><br><span class="line">    [item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &gt; array[<span class="number">0</span>]])</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
</blockquote>
<h2 id="算法理解-2"><a href="#算法理解-2" class="headerlink" title="算法理解"></a>算法理解</h2><ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">		current = arr[i]</span><br><span class="line">		preIndex = i - <span class="number">1</span></span><br><span class="line">		<span class="keyword">while</span> preIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[preIndex] &gt; current:</span><br><span class="line">			arr[preIndex+<span class="number">1</span>] = arr[preIndex]</span><br><span class="line">			preIndex -= <span class="number">1</span></span><br><span class="line">		arr[preIndex+<span class="number">1</span>] = current</span><br><span class="line">	<span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="算法理解-3"><a href="#算法理解-3" class="headerlink" title="算法理解"></a>算法理解</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    jmp = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> jmp != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(jmp, <span class="built_in">len</span>(arr)):</span><br><span class="line">            tmp = arr[i]</span><br><span class="line">            j = i - jmp</span><br><span class="line">            <span class="keyword">while</span> tmp &lt; arr[j] <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                arr[j + jmp] = arr[j]</span><br><span class="line">                j = j - jmp</span><br><span class="line">            arr[jmp + j] = tmp</span><br><span class="line">        print(<span class="string">&quot;第&#123;0&#125;次排序过程&quot;</span>.<span class="built_in">format</span>(k))</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        jmp = jmp // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">    res = shellSort(arr)</span><br><span class="line">    print(res)</span><br><span class="line">    print(insertSort([<span class="number">2</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<h2 id="算法理解-4"><a href="#算法理解-4" class="headerlink" title="算法理解"></a>算法理解</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1…n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R- 交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[minIndex]</span><br><span class="line">        arr[minIndex] = temp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">    res = selectionSort(arr)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法理解-5"><a href="#算法理解-5" class="headerlink" title="算法理解"></a>算法理解</h2><ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span>(<span class="params">arr, size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size // <span class="number">2</span>)[::-<span class="number">1</span>]:</span><br><span class="line">        ad_heap(arr, i, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ad_heap</span>(<span class="params">arr, i, size</span>):</span></span><br><span class="line">    lchild = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    rchild = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    maxs = i</span><br><span class="line">    <span class="keyword">if</span> i &lt; size // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> lchild &lt; size <span class="keyword">and</span> arr[lchild] &gt; arr[maxs]:</span><br><span class="line">            maxs = lchild</span><br><span class="line">        <span class="keyword">if</span> rchild &lt; size <span class="keyword">and</span> arr[rchild] &gt; arr[maxs]:</span><br><span class="line">            maxs = rchild</span><br><span class="line">        <span class="keyword">if</span> maxs != i:</span><br><span class="line">            arr[maxs], arr[i] = arr[i], arr[maxs]</span><br><span class="line">            ad_heap(arr, maxs, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr, size</span>):</span></span><br><span class="line">    build_heap(arr, size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size)[::-<span class="number">1</span>]:</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        ad_heap(arr, <span class="number">0</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">14</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">21</span>, <span class="number">19</span>]</span><br><span class="line">    heapSort(a, <span class="built_in">len</span>(a))</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法理解-6"><a href="#算法理解-6" class="headerlink" title="算法理解"></a>算法理解</h2><ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2020121521433053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片"></p>
<h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    lens = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> lens &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    middle = lens // <span class="number">2</span></span><br><span class="line">    left = arr[: middle]</span><br><span class="line">    right = arr[middle:]</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    c = []</span><br><span class="line">    h, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> h &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[j] &lt; right[h]:</span><br><span class="line">            c.append(left[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(right[h])</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(left):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> right[h:]:</span><br><span class="line">            c.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left[j:]:</span><br><span class="line">            c.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">14</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">21</span>, <span class="number">19</span>]</span><br><span class="line">    print(mergeSort(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>排序算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>比较类排序</tag>
        <tag>非比较类排序</tag>
      </tags>
  </entry>
  <entry>
    <title>详解MySQL中事务原理和锁机制</title>
    <url>/2021/03/10/%E8%AF%A6%E8%A7%A3MySQL%E4%B8%AD%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>是指作为<code>单个逻辑工作单元</code>执行的一系列操作，要么<code>完全的执行</code>，要么<code>完全的不执行</code>。事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功，要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑单元要成为事务，必须满足所谓的ACID(原子性、一致性、隔离性、持久性)属性。事务是数据库运行中的一个逻辑工作单元，由DBMS中的事务管理子系统负责事务的处理。</p>
<p><strong>举个栗子呀</strong></p>
<blockquote>
<p>同一个银行转账，A转1000块钱给B，这里存在两个操作，一个是A账户扣款1000元，两一个操作是B账户增加1000元，两者就构成了转账这个事务。</p>
</blockquote>
<ul>
<li>两个操作都成功，A账户扣款1000元，B账户增加1000元，事务成功</li>
<li>两个操作都失败，A账户和B账户金额都没变，事务失败</li>
</ul>
<p>最后思考一下，怎么样会出现A账户扣款1000元，B账户金额不变？如果你是把两个操作放在一个事务里面，并且是数据库提供的内在事务支持，那就不会有问题，但是开发人员把两个操作放在两个事务里面，而第二个事务失败就会出现中间状态。现实中自己实现的分布式事务处理不当也会出现中间状态，这并不是事务的错，事务本身就是规定不会出现中间状态，是事务实现者做出来的方案有问题。</p>
<h2 id="4个特性"><a href="#4个特性" class="headerlink" title="4个特性"></a>4个特性</h2><ul>
<li><strong>原子性（Atomic）</strong>：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</li>
<li><strong>一致性（Consistency）</strong>：事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。</li>
<li><strong>隔离性（Isolation）</strong>：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，到底是另一个事务执行之前的状态还是中间某个状态，相互之间存在什么影响，是可以通过隔离级别的设置来控制的。</li>
<li><strong>持久性（Durability）</strong>：事务结束后，事务处理的结果必须能够得到固化，即写入数据库文件中即使机器宕机数据也不会丢失，它对于系统的影响是永久性的。 </li>
</ul>
<h2 id="事务并发控制"><a href="#事务并发控制" class="headerlink" title="事务并发控制"></a>事务并发控制</h2><p>我们从另外一个方向来说说，如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形，有些使我们可以接受的，有些是不能接受的，注意这里的异常就是特定语境下的，并不一定就是错误什么的。假设有一个order表，有个字段叫count，作为计数用，当前值为100</p>
<ul>
<li><strong>第一类丢失更新（Update Lost）</strong>：此种更新丢失是因为回滚的原因，所以也叫<code>回滚丢失</code>。此时两个事务同时更新count，两个事务都读取到100，事务一更新成功并提交，count=100+1=101，事务二出于某种原因更新失败了，然后回滚，事务二就把count还原为它一开始读到的100，此时事务一的更新就这样丢失了。</li>
<li><strong>脏读（Dirty Read）</strong>：此种异常时因为一个事务读取了另一个事务修改了但是<code>未提交</code>的数据。举个例子，事务一更新了count=101，但是没有提交，事务二此时读取count，值为101而不是100，然后事务一出于某种原因回滚了，然后第二个事务读取的这个值就是噩梦的开始。</li>
<li><strong>不可重复读（Not Repeatable Read）</strong>：此种异常是一个事务对同一行数据执行了<code>两次或更多次查询</code>，但是却得到了不同的结果，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，不能保证每次读取的结果是一样的，有可能一样有可能不一样。造成这个结果是在两次查询之间有别的事务对该行数据做了更新操作。举个例子，事务一先查询了count，值为100，此时事务二更新了count=101，事务一再次读取count,值就会变成101，两次读取结果不一样。</li>
<li><strong>第二类丢失更新（Second     Update Lost）</strong>：此种更新丢失是因为更新被其他事务给覆盖了，也可以叫<code>覆盖丢失</code>。举个例子，两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，count=100+1=101，事务二后更新成功并提交，count=100+1=101,由于事务二count还是从100开始增加，事务一的更新就这样丢失了。</li>
<li><strong>幻读（Phantom     Read）</strong>：幻读和不可重复读有点像，只是针对的不是数据的值而是<code>数据的数量</code>。此种异常是一个事务在<code>两次查询</code>的过程中数据的<code>数量不同</code>，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询order表有多少条记录，事务二新增了一条记录，然后事务一查了一下order表有多少记录，发现和第一次不一样，这就是幻读。</li>
</ul>
<p><strong>图解</strong><br><img src="https://img-blog.csdnimg.cn/20210125114509938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="脏读"></p>
<p><img src="https://img-blog.csdnimg.cn/20210125114629253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="不可重复读"></p>
<p><img src="https://img-blog.csdnimg.cn/20210125114708560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="幻读"></p>
<p><strong>解决方案</strong><br><img src="https://img-blog.csdnimg.cn/20210125114742580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="脏读"></p>
<p><img src="https://img-blog.csdnimg.cn/20210125114834227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="不可重复读"></p>
<p><img src="https://img-blog.csdnimg.cn/20210125114949181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="幻读"></p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>看到上面提到的几种问题，你可能会想，我擦，这么多坑怎么办啊。其实上面几种情况并不是一定都要避免的，具体看你的业务要求，包括你数据库的负载都会影响你的决定。不知道大家发现没有，上面各种异常情况都是多个事务之间相互影响造成的，这说明两个事务之间需要某种方式将他们从某种程度上分开，降低直至避免相互影响。这时候数据库事务隔离级别就粉墨登场了，而数据库的隔离级别实现一般是通过数据库锁实现的。</p>
<ul>
<li><strong>读未提交（Read Uncommitted）：</strong> 该隔离级别指即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变，几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用。</li>
<li><strong>读已提交（Read Committed）：</strong> 该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，消除了脏读和第一类丢失更新，这是大多数数据库的默认隔离级别，如Oracle,Sqlserver。</li>
<li><strong>可重复读（Repeatable Read）：</strong> 该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，只要存在读改行数据就禁止写，消除了不可重复读和第二类更新丢失，这是Mysql数据库的默认隔离级别。</li>
<li><strong>串行化（Serializable）：</strong> 意思是说这个事务执行的时候不允许别的事务并发执行.完全串行化的读，只要存在读就禁止写,但可以同时读，消除了幻读。这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用。</li>
</ul>
<p><strong>下面是各种隔离级别对各异常的控制能力：</strong></p>
<table>
<thead>
<tr>
<th><strong>级别\异常</strong></th>
<th><strong>第一类更新丢失</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>第二类丢失更新</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>读已提交</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>可重复读</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>串行化</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>一般可以分为两类，一个是<code>悲观锁</code>，一个是<code>乐观锁</code>，悲观锁一般就是我们通常说的<code>数据库锁机制</code>，乐观锁一般是指用户<code>自己实现</code>的一种锁机制，比如hibernate实现的乐观锁甚至编程语言也有乐观锁的思想的应用。</p>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p><strong>悲观锁按照使用性质划分：</strong></p>
<ul>
<li><strong>共享锁（Share locks称为S锁）</strong> ：也称为<code>读锁</code>，事务A对对象T加<code>S锁</code>，其他事务也只能对T加<code>S锁</code>，多个事务可以同时读，但是不能有<code>写操作</code>，直到A释放S锁。</li>
<li><strong>排他锁（Exclusivelocks称为X锁）</strong> ：也成为<code>写锁</code>，事务A对对象T加<code>X锁</code>以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁</li>
<li><strong>更新锁（称为U锁）</strong>：用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。</li>
</ul>
<p><strong>悲观锁按照作用范围划分：</strong></p>
<p><strong>行锁：</strong> 锁的作用范围是<code>行级别</code>，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表user，有主键id和用户生日birthday当你使用update … where id=?这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用update … where birthday=?这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。<br>在InnoDB的事务中，行锁再需要的时候才加上的，但并不是不需要就立即释放，而是要等到事务结束时才释放，如果事务中需要锁多行, 那应该把最可能造成锁冲突, 影响并发度的锁尽量往后放</p>
<p><strong>表锁：</strong> 锁的作用范围是整张表。<br>lock talbes … read/write 可以使用unlock tables 主动释放锁, 也可以再客户端关闭的时候自动释放. 还没有出现更细颗粒度的锁时, 表锁是常用的处理并发的方式<br><code>元数据锁 MDL(metadata lock)</code>：不需要显示地使用, 在访问一个表的时候会被自动加上, 作用是保证读写的准确性.。对表的操作包括两种：对一张表进行 增删改查操作, 此时会加 MDL 读锁；对一张表的 结构进行变更操作(加字段/修改字段/删除字段/添加索引等)时, 此时会加 MDL 写锁。<br><code>元数据锁之间的互斥关系：</code>MDL 读锁之间不互斥, 因此可以有多个线程同时对一张表进行增删改查；读写锁, 写锁之间是互斥的, 用来保证表结构操作的安全性. 因此表持有写锁时, 该表的其他操作都被阻塞<br><code>注意：</code>大表操作的时候, 需要格外小心, 以免导致整个库宕掉; 一定要避开当前mysql中正在提交事务的表进行DDL；在alter table 的时候, 可以设定等待时间, 在这个时间内能能到MDL写锁则进行执行DDL语句, 如果不能拿到就先放弃不要阻塞后面的业务语句；alter等待时间设置语法: alter table t_test wait N add name varchar(32) not null default ‘’;</p>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>乐观锁</strong>：顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。既然都有数据库提供的悲观锁可以方便使用为什么要使用乐观锁呢？对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量。最后还要释放锁，锁是需要一些开销的，我们只要想办法解决极少量的更新操作的同步问题。换句话说，如果是读写比例差距不是非常大或者你的系统没有响应不及时，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。</p>
<p><strong>乐观锁实现方式：</strong></p>
<ul>
<li><strong>版本号（记为version）</strong>：就是给数据增加一个版本标识，在数据库上就是表中增加一个version字段，每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断version和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了version，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用update     … where … and version=”old     version”这样的语句，根据返回结果是0还是非0来得到通知，如果是0说明更新没有成功，因为version被改了，如果返回非0说明更新成功。</li>
<li><strong>时间戳（timestamp）</strong>：和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。</li>
<li><strong>待更新字段</strong>：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫count,先去读取这个count,更新的时候去比较数据库中count的值是不是我期望的值（即开始读的值），如果是就把我修改的count的值更新到该字段，否则更新失败。java的基本类型的原子类型对象如AtomicInteger就是这种思想。</li>
<li><strong>所有字段</strong>：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。</li>
</ul>
<p><strong>乐观锁几种方式的区别：</strong> 新系统设计可以使用version方式和timestamp方式，需要增加字段，应用范围是整条数据，不论那个字段修改都会更新version,也就是说两个事务更新同一条记录的两个不相关字段也是互斥的，不能同步进行。旧系统不能修改数据库表结构的时候使用数据字段作为版本控制信息，不需要新增字段，待更新字段方式只要其他事务修改的字段和当前事务修改的字段没有重叠就可以同步进行，并发性更高。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。这些永远在互相等待的进程称为死锁进程</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用</li>
<li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li>
<li>请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li>
<li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。</li>
</ul>
<p><strong>死锁产生的原因：</strong></p>
<ol>
<li><p>系统资源的竞争<br>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在 运行过程中，会因争夺资源而陷入僵局</p>
</li>
<li><p>进程推进顺序非法<br>进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程 P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都 会因为所需资源被占用而阻塞。</p>
</li>
<li><p>信号量使用不当也会造成死锁。<br>进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。</p>
</li>
</ol>
<p><strong>如何避免死锁？</strong><br>三种用于避免死锁的技术：</p>
<ul>
<li><p>加锁顺序：<br>  一个线程需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。<br>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(获取锁A是获取锁C的必要条件)。因为线程1已经拥有了锁A，<br>所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p>
</li>
<li><p>加锁时限 ：<br>  另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。<br>并会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，<br>并且让该应用在没有获得锁的时候可以继续运行(加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p>
</li>
<li><p>死锁检测：<br>  每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。<br>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。如果检测到死锁，就释放所有锁，回退，并且等待一段随机的时间后再重试</p>
</li>
</ul>
<p><strong>遇到死锁怎么办？</strong></p>
<p>我们先了解下死锁定理： </p>
<p>​           ①如果资源分配图中没有环路，则系统没有死锁； </p>
<p>​           ②如果资源分配图中出现了环路，则系统可能有死锁。</p>
<p>从上面的死锁定理中我们可以知道只要打破死锁的环路就可以解开死锁，以下是处理死锁的两种名方法：</p>
<p>1）抢占资源：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p>
<p>2）终止（或撤销）进程：终止或撤销系统中的一个或多个死锁进程，直至打破死锁状态</p>
<p><code>进入死锁的线程进行等待, 直到超时自动退出. 超时参数可以通过innodb_lock_wait_timeout(默认50s)设置</code><br><code>发起死锁检测, 发现死锁后, 主动回滚掉其中一条事务, 让其他的事务得以执行, innodb_deadlock_deteck 设置为on, 这也是默认值, 表示开启这个逻辑</code></p>
<p><strong>加锁的规则</strong></p>
<ol>
<li>原则上：加锁的基本单位是<code>next-key lock</code>，是一个前开后闭区间，锁是加在索引上的</li>
<li>原则上：查找过程中访问的对象才会加锁</li>
<li>优化：索引上的等值查询，该唯一索引加锁的时候，next-key lock退化为<code>行锁</code></li>
<li>优化：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为<code>间隙锁</code></li>
<li>优化：唯一索引上的范围查询会访问到不满足条件的第一值为止</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>傻傻分不清之Cookie、Session、Token、JWT</title>
    <url>/2021/03/09/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8BCookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="认证-Authentication"><a href="#认证-Authentication" class="headerlink" title="认证(Authentication)"></a>认证(Authentication)</h1><ul>
<li>通俗地讲就是<code>验证当前用户的身份</code>，证明 “你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</li>
<li>互联网中的认证：<ul>
<li>用户名密码登录</li>
<li>邮箱发送登录链接</li>
<li>手机号接收验证码</li>
<li>只要你能收到邮箱 / 验证码，就默认你是账号的主人</li>
</ul>
</li>
</ul>
<h1 id="授权-Authorization"><a href="#授权-Authorization" class="headerlink" title="授权(Authorization)"></a>授权(Authorization)</h1><ul>
<li>用户授权第三方应用<code>访问</code>该用户某些<code>资源</code>的<code>权限</code><ul>
<li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</li>
<li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li>
</ul>
</li>
<li>实现授权的方式有：cookie、session、token、OAuth</li>
</ul>
<h1 id="凭证-Credentials"><a href="#凭证-Credentials" class="headerlink" title="凭证(Credentials)"></a>凭证(Credentials)</h1><ul>
<li>实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份<ul>
<li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</li>
<li>在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡 / 银行卡 / 个人贷款 / 交通出行等等，这就是认证的凭证。</li>
<li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞 / 收藏 / 分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li>
</ul>
</li>
</ul>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><strong>HTTP是无状态的协议(对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务器端不会保存任何会话信息)。</strong>每一个请求都是<code>完全独立</code>的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行<code>会话跟踪</code>（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 <code>cookie </code>或<code>session</code>去实现。</p>
<ul>
<li><strong>cookie存储在客户端</strong><br>  <code>cookie</code>是<code>服务器</code>发送到用户浏览器并保存在<code>本地</code>的一块<code>数据</code>，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>
<li><strong>cookie是不可跨域的</strong><br>  每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。</li>
</ul>
<p><strong>cookie的重要性</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name = value</td>
<td align="left">键值对，设置cookie的名称及相对应的值，都必须是字符串类型</td>
</tr>
</tbody></table>
<ul>
<li>如果值为<code>Unicode</code>字符，需要为<code>字符编码</code>。</li>
<li>如果值为二进制数据，则需要使用 BASE64 编码。<ul>
<li><code>domain</code>指定<code>cookie</code>所属域名，默认是当前域名 | | path | 指定 cookie 在哪个路径（路由）下生效，默认是 ‘/‘。</li>
<li>如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。| | maxAge | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。</li>
</ul>
</li>
<li>比 expires 好用。<ul>
<li>| | expires | 过期时间，在设置的某个时间点后该 cookie 就会失效。<br>一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个<code>cookie</code>也就会被删除<code>secure</code>该<code>cookie</code>是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。</li>
<li>当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。| | httpOnly | 如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 </li>
</ul>
</li>
</ul>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><code>session</code>是另外一种记录服务器和客户端会话状态的机制。<code>session</code>是基于<code>cookie</code>实现的，session存储在服务器端，<code>sessionid</code>会被存储在客户端的<code>cookie</code>中</p>
<p><strong>session认证流程</strong><br><img src="https://img-blog.csdnimg.cn/20201230023113228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="session认证流程"></p>
<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的<code>session</code></li>
<li>请求返回时将此<code>session</code>的唯一标识信息 <code>sessionID</code>返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
<p><strong>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</strong></p>
<h1 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h1><ul>
<li>安全性<br>  session比cookie安全，session是存储在服务器端的<br>  cookie是存储在客户端</li>
<li>存取值的类型不同<br>  cookie只支持字符串数据，想要设置其他类型的数据，需要将其转换为字符串<br>  session可以存任意数据类型</li>
<li>有效期<br>  cookie可设置为长时间保持，比如我们经常使用的默认登录功能<br>  session一般失效时间较短，客户端关闭或session超时都会失效</li>
<li>存储大小不同<br>  单个cookie保存的数据不能超过4K<br>  session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源</li>
</ul>
<h1 id="token-令牌"><a href="#token-令牌" class="headerlink" title="token(令牌)"></a>token(令牌)</h1><h2 id="Access-Token"><a href="#Access-Token" class="headerlink" title="Access Token"></a>Access Token</h2><p>访问资源接口(API)时所需要的资源令牌</p>
<p>简单token的组成：<code>uuid</code>用户唯一的身份标识、<code>time</code>当前时间的时间戳、<code>sign</code>(签名,token的前几位以哈希算法压缩成的一定长度的十六进制字符串)</p>
<p><strong>特点</strong></p>
<ul>
<li>服务端无状态化，可扩展性好</li>
<li>支持移动端设备</li>
<li>安全</li>
<li>支持跨程序调用</li>
</ul>
<p><strong>token的身份验证流程</strong><br><img src="https://img-blog.csdnimg.cn/20201230023718475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="token的身份验证流程"></p>
<ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里    </li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li>
<li>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</li>
</ul>
<blockquote>
<p>基于<code>token</code>的用户认证是一种服务端<code>无状态</code>的认证方式，服务端不用存放<code>token</code>数据。用解析<code>token</code>的计算时间换取<code>session</code>的存储空间，从而减轻服务器的压力，减少频繁的查询数据库<br><code>token</code>完全由应用管理，所以它可以<code>避开同源策略</code></p>
</blockquote>
<h2 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h2><p><code>refresh token</code>是专用于刷新<code>access token</code>的 <code>token</code>。如果没有<code> refresh token</code>，也可以刷新 <code>a</code>ccess token<code>，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 </code>refresh token`，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20201230024210486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片"></p>
<blockquote>
<p><code>Access Token</code>的有效期比较短，当<code>Acesss Token</code>由于过期而失效时，使用<code>Refresh Token</code>就可以获取到新的<code>Token</code>，如果 <code>Refresh Token </code>也失效了，用户就只能重新登录了。<br><code>Refresh Token</code>及<code>过期时间</code>是存储在<code>服务器</code>的数据库中，只有在申请新的<code> Acesss Token</code> 时才会验证，不会对业务接口响应时间造成影响，也不需要向<code> Session</code> 一样一直保持在内存中以应对大量的请求。</p>
</blockquote>
<h1 id="Token和Session的区别"><a href="#Token和Session的区别" class="headerlink" title="Token和Session的区别"></a>Token和Session的区别</h1><ul>
<li><p><code>Session</code>是一种记录<code>服务器</code>和<code>客户端</code>会话状态的机制，使服务端有状态化，可以记录会话信息。而<code>Token</code>是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。</p>
</li>
<li><p><code>Session</code> 和 <code>Token </code>并不矛盾，作为身份认证 <code>Token </code>安全性比<code>Session</code>好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</p>
</li>
<li><p>所谓<code>Session认证</code>只是简单的把 User 信息存储到 <code>Session </code>里，因为 <code>SessionID</code> 的不可预测性，暂且认为是安全的。而 <code>Token</code> ，如果指的是 <code>OAuth Token </code>或类似的机制的话，提供的是 <code>认证 </code>和<code> 授权</code> ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。<code>Session </code>只提供一种简单的认证，即只要有此 <code>SessionID</code> ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</p>
</li>
</ul>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>Json Web Token</code>(简称jwt)是目前最流行的跨域认证解决方案，是一种认证授权机制。JWT是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准。JWT的声明一般被用来在身份提供者和服务提供者传递被认证的用户身份信息，以便于资源服务器获取资源。比如用户的登录。可以使用<code>HMAC算法</code>或者是<code>RSA的公/私秘钥</code>对<code>JWT</code>进行签名。因为数字签名的存在，这些传递的信息是可信的。阮一峰老师的 JSON Web Token 入门教程 讲的非常通俗易懂。</p>
<h2 id="生成JWT"><a href="#生成JWT" class="headerlink" title="生成JWT"></a>生成JWT</h2><p><a href="http://www.jwt.io/">www.jwt.io/</a><br><a href="http://www.jsonwebtoken.io/">www.jsonwebtoken.io/</a></p>
<h2 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h2><p><img src="https://img-blog.csdnimg.cn/20201230024317770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="原理"></p>
<p><strong>JWT认证流程</strong></p>
<ul>
<li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT</li>
<li>客户端将token保存到本地(通常使用localstorage或者cookie)</li>
<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的<code>Authorization</code>字段中使用<code>Bearer</code>模式添加<code>JWT</code>，其内容看起来是下面这样<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为<br>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要<br>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）<br>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</p>
</blockquote>
<h2 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h2><blockquote>
<p>项目：<a href="https://github.com/yjdjiayou/jwt-demo">https://github.com/yjdjiayou/jwt-demo</a></p>
</blockquote>
<p><strong>方式一</strong><br>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;calendar&#x2F;v1&#x2F;events</span><br><span class="line">Host: api.example.com</span><br><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>用户的状态不会存储在服务端的内存中，这是一种 无状态的认证机制</li>
</ul>
</blockquote>
<ul>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li>
<li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li>
<li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li>
<li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
</ul>
<p><strong>方式二</strong><br>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</p>
<p><strong>方式三</strong><br>通过 URL 传输 <a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx</a></p>
<h1 id="Token-和-JWT-的区别"><a href="#Token-和-JWT-的区别" class="headerlink" title="Token 和 JWT 的区别"></a>Token 和 JWT 的区别</h1><ul>
<li>相同：<ul>
<li>都是访问资源的令牌</li>
<li>都可以记录用户的信息</li>
<li>都是使服务端无状态化</li>
<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li>
</ul>
</li>
<li>区别：<ul>
<li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li>
<li>JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li>
</ul>
</li>
</ul>
<h1 id="常见的加密算法"><a href="#常见的加密算法" class="headerlink" title="常见的加密算法"></a>常见的加密算法</h1><p><img src="https://img-blog.csdnimg.cn/20201230024511539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="算法"></p>
<ul>
<li>哈希算法 (Hash Algorithm) 又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字 “指纹” 的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。</li>
<li>哈希算法主要用来保障数据真实性 (即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。</li>
<li>哈希算法通常有以下几个特点：<ul>
<li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别</li>
<li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别</li>
<li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方</li>
<li>正像快速：原始数据可以快速计算出哈希值</li>
<li>逆向困难：通过哈希值基本不可能推导出原始数据</li>
<li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大</li>
<li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong><br>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。<br>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。</p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>cookie、session、token</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>一文让你彻底弄清楚python中装饰器</title>
    <url>/2021/03/07/%E4%B8%80%E6%96%87%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E5%BC%84%E6%B8%85%E6%A5%9Apython%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>面试官：你了解装饰器吗？<br>XXX：了解<br>面试官：那你说说吧<br>XXX：装饰器是…<br>面试官：你先写一个简单的装饰器，再写一个带参的装饰器<br>XXX：xxx。。。<br>面试官：你知道装饰器有哪些应用场景吗<br>XXX：xxx。。。(思考)</p>
</blockquote>
<p>​大家是否在面试过程中，经常会遇到上面的问题？本文就让我们一起学习python中装饰器。</p>
<p><code>装饰器(decorator)</code>可以说是Python的一个神器，它可以在不改变一个函数代码和调用方式的情况下给函数添加新的功能。Python的装饰器同时也是Python学习从入门到精通过程中必需要熟练掌握的知识。今天尝试用浅显的语言解释下Python装饰器的工作原理及如何编写自己的装饰器吧。</p>
<hr>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>我们先来了解一下它有那些<code>应用场景</code></p>
<ul>
<li>附加功能</li>
<li>数据的清理或添加:<ul>
<li>函数参数类型验证 @require_ints 类似请求前拦截</li>
<li>数据格式转换 将函数返回字典改为 JSON/YAML 类似响应后篡改</li>
<li>为函数提供额外的数据 mock.patch</li>
</ul>
</li>
<li>函数注册<ul>
<li>在任务中心注册一个任务</li>
<li>注册一个带信号处理器的函数</li>
</ul>
</li>
</ul>
<p>你可能还是不理解装饰器是啥？没有关系，下面我们详细的解析一下到底如何去实现装饰器。</p>
<h1 id="最简单的装饰器"><a href="#最简单的装饰器" class="headerlink" title="最简单的装饰器"></a>最简单的装饰器</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&#x27;用时:&#123;&#125;秒&#x27;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@getTime</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;Func1 is running.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func1()</span><br></pre></td></tr></table></figure>
<p>上面的代码，<code>func1</code>函数被<code>getTime</code>函数装饰，这个装饰器实现的功能是<code>统计func1函数执行的时间</code>，这其实就是一个最简单的装饰器。<br>如何你还是不太理解，没有关系，我们换种写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&#x27;用时:&#123;&#125;秒&#x27;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;Func1 is running.&quot;</span>)</span><br><span class="line">res = getTime(func1)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<p>这种写法是不是清晰很多。如果你还是不太理解，也没有关系，接下来我们就看看装饰器的本质。</p>
<h1 id="本质上的装饰器"><a href="#本质上的装饰器" class="headerlink" title="本质上的装饰器"></a>本质上的装饰器</h1><p>Python的装饰器本质上是一个<code>嵌套函数</code>，它接受被装饰的函数(func)作为参数，并返回一个包装过的函数。这样我们可以在不改变被装饰函数的代码的情况下给被装饰函数或程序添加新的功能。</p>
<p>Python的装饰器广泛应用于<code>引入日志</code>，<code>执行函数前预备处理</code>，<code>执行函数后清理功能</code>，<code>权限校验</code>(如django中的@login_required和@permission_required装饰器)，<code>缓存</code>，<code>事务处理</code>、<code>性能测试</code>(比如统计一段程序的运行时间)和<code>插入日志</code>等应用场景。有了装饰器，我们就可以抽离出大量与函数功能本身无关的代码，增加一个函数的重用性。</p>
<p>试想你写了很多程序，一直运行也没啥问题。有一天老板突然让你统计每个程序都运行了多长时间并比较下运行效率。此时如果你去手动修改每个程序的代码一定会让你抓狂，而且还破坏了那些程序的重用性。聪明的程序员是绝不能干这种蠢事的。此时你可以编写一个<code>@time_it</code>的装饰器。如果你想打印出某个函数或程序运行时间，只需在函数前面@一下，是不是很帅?</p>
<p>由于Python装饰器的工作原理主要依赖于<code>嵌套函数</code>和<code>闭包</code>，所以我们必须先对嵌套函数和闭包有深入的了解。嵌套函数和闭包几乎是Python工作面试必考题哦。闭包相关的讲解请点击: <a href="https://liuwangleo.github.io/2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/">python之作用域和闭包详解</a></p>
<h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>如果在一个函数的内部还定义了另一个函数(注意: 是定义，不是引用!），这个函数就叫<code>嵌套函数</code>。外部的我们叫它<code>外函数</code>，内部的我们叫他<code>内函数</code>。</p>
<p>我们先来看一个最简单的嵌套函数的例子。我们在<code>outer函数</code>里又定义了一<code>个inner函数</code>，并调用了它。你注意到了吗? 内函数在自己作用域内查找局部变量失败后，会进一步向上一层作用域里查找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        y = x + <span class="number">1</span></span><br><span class="line">        print(y)</span><br><span class="line">    inner()</span><br><span class="line"></span><br><span class="line">outer() <span class="comment">#输出结果 2</span></span><br></pre></td></tr></table></figure>

<p>如果我们在外函数里不直接调用内函数，而是通过return inner返回一个内函数的引用 这时会发生什么呢? 你将会得到一个内函数对象，而不是运行结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        y = x + <span class="number">1</span></span><br><span class="line">        print(y)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">outer() <span class="comment"># 输出&lt;function outer.&lt;locals&gt;.inner at 0x039248E8&gt;</span></span><br><span class="line">f1 = outer()</span><br><span class="line">f1() <span class="comment"># 输出2</span></span><br></pre></td></tr></table></figure>

<p>上述这个案例比较简单，因为outer和inner函数都是没有参数的。我们现在对上述代码做点改动，加入参数。你可以看到外函数的参数或变量可以很容易传递到内函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">x</span>):</span></span><br><span class="line">    a = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">y</span>):</span></span><br><span class="line">        b = y</span><br><span class="line">        print(a+b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f1 = outer(<span class="number">1</span>) <span class="comment"># 返回inner函数对象</span></span><br><span class="line">f1(<span class="number">10</span>) <span class="comment"># 相当于inner(10)。输出11</span></span><br></pre></td></tr></table></figure>

<p>如果上例中外函数的<code>变量x</code>换成被<code>装饰函数对象(func)</code>，内函数的<code>变量y</code>换成<code>被装饰函数的参数</code>，我们就可以得到一个通用的装饰器啦。你注意到了吗? 我们在没对func本身做任何修改的情况下，添加了其它功能, 从而实现了对函数的装饰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        add_other_actions()</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="https://liuwangleo.github.io/2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/">python之作用域和闭包详解</a></p>
<h1 id="面试中的装饰器"><a href="#面试中的装饰器" class="headerlink" title="面试中的装饰器"></a>面试中的装饰器</h1><h2 id="基本的装饰器"><a href="#基本的装饰器" class="headerlink" title="基本的装饰器"></a>基本的装饰器</h2><p>面试官往往会给你提一些简单的需求，如返回被装饰函数执行时间，函数的名称等，这时候要学会灵活的转变。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;&#123;0&#125; is running&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hint</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;say hello!&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用  hello()<br>执行结果：hello is running / say hello!</p>
</blockquote>
<p>值得一提的是被装饰器装饰过的函数看上去名字没变，其实已经变了。当你运行<code>print(hello.__name__)</code>后，你会发现它的名字已经悄悄变成了<code>warpper</code>，这显然不是我们想要的。这一点也不奇怪，因为外函数返回的是由<code>warpper函数</code>和其<code>外部引用变量</code>组成的闭包。</p>
<p><img src="https://img-blog.csdnimg.cn/20201211095412663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片描述"></p>
<p>为了解决这个问题保证装饰过的函数<code>__name__</code>属性不变，我们可以使用<code>functools</code>模块里的<code>wraps</code>方法，先对<code>func</code>变量进行<code>wraps</code>。下面这段代码可以作为编写一个通用装饰器的示范代码，注意收藏哦。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; is running&#x27;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hint</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="带参的装饰器"><a href="#带参的装饰器" class="headerlink" title="带参的装饰器"></a>带参的装饰器</h2><p>前面几个装饰器一般是<code>内外两层嵌套函数</code>。如果我们需要编写的装饰器本身是带参数的，我们需要编写三层的嵌套函数，其中最外一层用来传递装饰器的参数。现在我们要对@hint装饰器做点改进，使其能通过@hint(coder=’liuwangleo’)传递参数。该装饰器在函数运行前给出提示的时候还显示函数编写人员的名字。完整代码如下所示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">coder</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            print(<span class="string">&#x27;&#123;&#125; is running&#x27;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">            print(<span class="string">&#x27;Coder: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(coder))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hint(<span class="params">coder=<span class="string">&quot;liuwangleo&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>先来一段代码，自行理解一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d1</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">       print(<span class="number">1</span>)</span><br><span class="line">       f()</span><br><span class="line">       print(<span class="string">&quot;我是外边的装饰器&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d2</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="number">2</span>)</span><br><span class="line">        print(f.__name__)</span><br><span class="line">        f()</span><br><span class="line">        print(<span class="string">&quot;我是里边的装饰器&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;哈哈哈&#x27;</span>)</span><br><span class="line">func()</span><br><span class="line"><span class="comment"># 执行结果是啥呢？</span></span><br></pre></td></tr></table></figure>

<p>不知道你能否理解，如果不明白没有关系，前面我们介绍过装饰器就是嵌套函数，不妨还是换种写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d1</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="number">2</span>)</span><br><span class="line">        f()</span><br><span class="line">        print(<span class="string">&quot;我是外边的装饰器&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d2</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line">        print(f.__name__)</span><br><span class="line">        f()</span><br><span class="line">        print(<span class="string">&quot;我是里边的装饰器&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;哈哈哈&#x27;</span>)</span><br><span class="line">res = d1(d2(func))</span><br></pre></td></tr></table></figure>
<p>这样是不是就容易理解了，执行结果呢？来了来了。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">func</span><br><span class="line">哈哈哈</span><br><span class="line">我是里边的装饰器</span><br><span class="line">我是外边的装饰器</span><br></pre></td></tr></table></figure>

<p>如果上面代码没看够，那就再来一段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">funE_decorated_by_C</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">funE_decorated_by_C</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">redecorated_E</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">        print(<span class="string">&quot;开始执行&quot;</span>, end=<span class="string">&quot;——&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> funE_decorated_by_C(<span class="built_in">str</span>) + <span class="string">&#x27; &gt; redecorated by A&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> redecorated_E</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span>(<span class="params">funE</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">funE</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated_E</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> funE(<span class="built_in">str</span>) + <span class="string">&#x27; &gt; decorated by C&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> decorated_E</span><br><span class="line"><span class="meta">@A</span></span><br><span class="line"><span class="meta">@C</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">E</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line">print(E(<span class="string">&#x27;A string is &#x27;</span>))</span><br><span class="line">print(E.__name__)</span><br></pre></td></tr></table></figure>

<p><strong>接下来不要眨眼，让我们详细的看一下这种多个装饰器的执行过程</strong></p>
<hr>
<p><code>开始执行——&gt; A string is &gt; decorated by C &gt; redecorated by A</code></p>
<p>难理解的地方在C和A在装饰过程中执行的调用关系</p>
<ul>
<li><p>可以看到，<code>先调用那个装饰器，那个装饰器就先运行</code><br>  print(“开始执行”, end=”——&gt;”)</p>
</li>
<li><p>继续执行 A装饰的是<code>C(A)</code> 即调用 <code>funE_decorated_by_C</code><br>  调用<code> funE_decorated_by_C</code> 执行C</p>
</li>
<li><p>C执行 调用E函数 返回的结果<code>&quot; A string is &gt; decorated by C &quot;</code>  作为A中 <code>funE_decorated_by_C</code> 的<code>参数</code></p>
</li>
<li><p>最终在A中调用E 返回 A</p>
</li>
</ul>
<hr>
<p>最后在附上一份案例代码，供参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span>(<span class="params">fun</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_b</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;This is inner_b&#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;*****&quot;</span>)</span><br><span class="line">        <span class="comment"># print(fun(*args, **kwargs))</span></span><br><span class="line">        <span class="keyword">return</span> fun(*args, **kwargs) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span>(<span class="params">fun</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_a</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;This is inner_a&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> fun(*args, **kwargs) + <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;This is f&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h1 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h1><p><a href="https://www.cnblogs.com/Lin-Yi/p/7305364.html">https://www.cnblogs.com/Lin-Yi/p/7305364.html</a><br><a href="http://python.jobbole.com/81683/">http://python.jobbole.com/81683/</a><br><a href="http://lib.csdn.net/article/python/62942">http://lib.csdn.net/article/python/62942</a><br><a href="http://lib.csdn.net/article/python/64769">http://lib.csdn.net/article/python/64769</a><br><a href="http://www.cnblogs.com/cicaday/p/python-decorator.html">http://www.cnblogs.com/cicaday/p/python-decorator.html</a></p>
<p>最新推荐：<br>    <a href="https://mp.weixin.qq.com/s/XTHZ-K1yDNPIoejNFvk6rw">恶补了 Python 装饰器的六种写法，你随便问~</a><br>    <a href="https://blog.csdn.net/LaoYuanPython/article/details/111303395">各种各样的装饰器实现详解</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>python之作用域与闭包详解</title>
    <url>/2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用域介绍"><a href="#作用域介绍" class="headerlink" title="作用域介绍"></a>作用域介绍</h1><p>作用域，也叫名称空间。</p>
<h2 id="几个相关的概念"><a href="#几个相关的概念" class="headerlink" title="几个相关的概念"></a>几个相关的概念</h2><ul>
<li>全局名称空间：创建的存储“变量名与值的关系”的空间叫做全局名称空间</li>
<li>局部名称空间：在函数的运行中开辟的临时的空间叫做局部名称空间</li>
<li>内置名称空间：内置名称空间中存放了python解释器为我们提供的名字：input,print,str,list,tuple…它们都是我们熟悉的，拿过来就可以用的方法。</li>
</ul>
<h2 id="python的作用域"><a href="#python的作用域" class="headerlink" title="python的作用域"></a>python的作用域</h2><ul>
<li>L：local，局部作用域，即函数中定义的变量；</li>
<li>E：enclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域，但不是全局的（闭包常见）；</li>
<li>G：globa，全局变量，就是模块级别定义的变量；</li>
<li>B：built-in，系统固定模块里面的变量，比如int, bytearray等。</li>
</ul>
<p><code>加载变量的优先顺序是由下至上</code><br><code>搜索变量的优先顺序是由上至下，LEGB法则</code></p>
<h1 id="作用域产生"><a href="#作用域产生" class="headerlink" title="作用域产生"></a>作用域产生</h1><p>在Python中，只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如if、try、for等）是不会引入新的作用域的，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span>&gt;<span class="number">1</span>:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">print(x)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>这个是没有问题的，if并没有引入一个新的作用域，x仍处在当前作用域中，后面代码可以使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">print(x) <span class="comment"># NameError: name &#x27;x2&#x27; is not defined</span></span><br></pre></td></tr></table></figure>

<h1 id="案例和几个关键字"><a href="#案例和几个关键字" class="headerlink" title="案例和几个关键字"></a>案例和几个关键字</h1><h2 id="变量的声明和使用"><a href="#变量的声明和使用" class="headerlink" title="变量的声明和使用"></a>变量的声明和使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line">    x=<span class="number">1</span></span><br><span class="line">f2()</span><br><span class="line"><span class="comment"># local variable &#x27;x&#x27; referenced before assignment</span></span><br></pre></td></tr></table></figure>
<p>上面的代码执行是会报错的，我们都知道变量是先声明，再引用的，错误的原因在于 print(x)，解释器会在局部作用域找，会找到x=1(函数已经加载到内存),但x使用在声明前了,所以报错；如何证明找到了x=1呢?简单:注释掉x=2,x=1,报错为:<code>name &#39;x&#39; is not defined</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    x+=<span class="number">1</span> <span class="comment">#local variable &#x27;x&#x27; referenced before assignment.  x 使用之前已经被声明了</span></span><br><span class="line"><span class="comment">#x+=1：x = x + 1；x 已经被声明了，x=2，这里等于 2 = 2 + 1，发生报错</span></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure>
<h2 id="global关键字"><a href="#global关键字" class="headerlink" title="global关键字"></a>global关键字</h2><p>针对上边代码的报错，我们知道在局部作用域里是不能操作全局变量的，我们先看一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">	a = <span class="number">200</span></span><br><span class="line">	print(a)</span><br><span class="line">f()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure>
<p>如果要是想修改这个全局变量a的值，在python中有关键字可以实现这个需求—global</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># global关键字可以在局部中修改全局的变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)</span><br><span class="line">f()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 200</span></span><br></pre></td></tr></table></figure>
<h2 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nonlocal关键字可以修改嵌套的父级函数的局部变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    count = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count = <span class="number">20</span></span><br><span class="line">        print(count)</span><br><span class="line">    inner()</span><br><span class="line">    print(count)</span><br><span class="line">outer()</span><br><span class="line"><span class="comment"># 20</span></span><br><span class="line"><span class="comment"># 20</span></span><br></pre></td></tr></table></figure>
<p>这段代码是不是看着有点懵比呢。这是因为这个函数使用到了闭包，<strong>inner</strong>函数中使用<strong>nonlocal **修改了count的值，</strong>nonlocal关键字可以修改嵌套的父级函数的局部变量的值<strong>，下面我们了解一下</strong>闭包**</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="特别简单的介绍"><a href="#特别简单的介绍" class="headerlink" title="特别简单的介绍"></a>特别简单的介绍</h2><p> 还是先来段代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span>  </span><br><span class="line">    x = <span class="number">1</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span>  </span><br><span class="line">        print(x) <span class="comment"># 1  </span></span><br><span class="line">    <span class="keyword">return</span> inner  </span><br><span class="line">foo = outer()  </span><br><span class="line">print(foo)</span><br><span class="line"><span class="comment"># &lt;function outer.&lt;locals&gt;.inner at 0x000001EDE42878C8&gt; </span></span><br><span class="line">foo()  </span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p><strong>其实这就是闭包</strong></p>
<p>闭包的三要素：</p>
<ul>
<li>定义两个函数内部函数与外部函数  </li>
<li>在外部函数中存在一个自由变量，内部函数使用 </li>
<li>外部函数的返回值调用内部函数</li>
</ul>
<blockquote>
<p>在你面试的时候回答闭包问题，完全可以直接附上代码，讲出三要素</p>
</blockquote>
<h2 id="闭包的陷阱"><a href="#闭包的陷阱" class="headerlink" title="闭包的陷阱"></a>闭包的陷阱</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">*args</span>):</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">            <span class="keyword">return</span> i * i</span><br><span class="line">        fs.append(func)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">fs1, fs2, fs3 = my_func()</span><br><span class="line">print(fs1())</span><br><span class="line">print(fs2())</span><br><span class="line">print(fs3())</span><br><span class="line"><span class="comment"># 全部返回值为 4</span></span><br><span class="line"><span class="comment"># 返回闭包中不要引用任何循环变量，或者后续会发生变化的变量。</span></span><br><span class="line"><span class="comment"># 这条规则本质上是在返回闭包前，闭包中引用的父函数中定义变量的值可能会发生不是我们期望的变化。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">*args</span>):</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        func = <span class="keyword">lambda</span> _i = i : _i * _i</span><br><span class="line">        fs.append(func)</span><br><span class="line"><span class="keyword">return</span> fs</span><br><span class="line"><span class="comment"># 这个函数返回什么呢？思考一下，可以留言回复</span></span><br></pre></td></tr></table></figure>
<p>其实就这些东西，一次性弄清楚之后，再遇到相关的问题就不会概念不清，思路混乱。讲到闭包其实<strong>装饰器</strong>也不得不说，装饰器基本面试或者工作用的比较多，之后会专门更一篇相关的博文。<br><a href="https://blog.csdn.net/qq_36581961/article/details/111028518"><strong>在这里：专题九:如何应对面试官的拷问—你了解python的装饰器吗？</strong></a></p>
<p><strong>谢谢观看，点赞关注不迷路，我很菜还不爱说！</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
        <tag>作用域</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>树的面试题总结</title>
    <url>/2021/03/05/%E6%A0%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树的几个概念"><a href="#树的几个概念" class="headerlink" title="树的几个概念"></a>树的几个概念</h1><p>由一个或一个以上的节点组成，存在一个特殊的节点，成为树根。其中的每一个子集合本身也是一种树形结构，即此根节点的子树。</p>
<p>几个关于树的专有名词</p>
<ul>
<li>度数：每个节点所有子树的个数</li>
<li>层数：树的层数</li>
<li>高度：树的最大层数</li>
<li>树叶或终端节点：度数为零的节点就是树叶。</li>
<li>父节点：每一个节点都有连接的上一层节点。</li>
<li>子节点：每一个节点都有连接的下一层节点。</li>
<li>兄弟节点：有共同父节点的节点。</li>
<li>非终端节点：树叶以内的节点。</li>
<li>同代：在同一棵具有相同层数的节点。</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>由有限节点所组成的集合，此结合可以为空集合，或由一个树根及其左右两个子树组成。<br><strong>特点</strong></p>
<ul>
<li>可以是空集合 但若不是空集合 则节点上一定要有一个键值</li>
<li>每一个树根的值需大于左子树的值</li>
<li>每一个树根的值需小于右子树的值</li>
<li>左右子树也是二叉查找树</li>
<li>树的每一个节点的值都不相同</li>
</ul>
<p><strong>二叉树与树的区别</strong></p>
<ul>
<li>树不可以为空集合 二叉树可以</li>
<li>树的度数为d&gt;=0 但二叉树的节点度数为0&lt;=0&lt;=2</li>
<li>树的子树没有次序关系 二叉树则有</li>
</ul>
<blockquote>
<p>高度为k的二叉树的总结点数为 2<strong>k-1<br>在二叉树中，层数为i的节点数最多为 2</strong>(i-1)</p>
</blockquote>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组的方式存储</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeCreateByArray</span>(<span class="params">btree, data, length</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> btree[level] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> data[i] &gt; btree[level]:  <span class="comment"># 如果数组内的值大于树根 就往右子树比较</span></span><br><span class="line">                level = level * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                level = level * <span class="number">2</span></span><br><span class="line">        btree[level] = data[i]</span><br><span class="line">    <span class="keyword">return</span> btree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表的存储方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = <span class="number">0</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeCreateByLinkList</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    newnode = tree()</span><br><span class="line">    newnode.data = val</span><br><span class="line">    newnode.left = <span class="literal">None</span></span><br><span class="line">    newnode.right = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        root = newnode</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">            backup = current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current = current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt; val:</span><br><span class="line">            backup.left = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right = newnode</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">二叉树查找：</span></span><br><span class="line"><span class="string">def search(ptr,val):</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        if ptr is None:</span></span><br><span class="line"><span class="string">            return None</span></span><br><span class="line"><span class="string">        if ptr.data == val:</span></span><br><span class="line"><span class="string">            return ptr</span></span><br><span class="line"><span class="string">        elif ptr.data &gt;val:</span></span><br><span class="line"><span class="string">            ptr = ptr.left</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            ptr = ptr.right</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = <span class="number">0</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个二叉树</span></span><br><span class="line"><span class="string">    :param root:</span></span><br><span class="line"><span class="string">    :param val:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    newnode = Tree()</span><br><span class="line">    newnode.data = val</span><br><span class="line">    newnode.left = <span class="literal">None</span></span><br><span class="line">    newnode.right = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        root = newnode</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            backup = current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current = current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt; val:</span><br><span class="line">            backup.left = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right = newnode</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.data == val:</span><br><span class="line">            print(<span class="string">&quot;查找了&#123;0&#125;次&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> root.data &gt; val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.right</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        inorder(root.left)</span><br><span class="line">        print(<span class="string">&quot;[%2d]&quot;</span> % root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        inorder(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br><span class="line">    root = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        root = createTree(root, data[i])</span><br><span class="line">    target = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入查找的数值&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> search(root, target) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">&quot;找到了&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;NO NO ...没找到&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;准备插入&quot;</span>)</span><br><span class="line">        root = createTree(root, target)</span><br><span class="line">        inorder(root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">存在三种情况：</span></span><br><span class="line"><span class="string">1.删除的节点为树叶，只要将其相连的父节点指向None</span></span><br><span class="line"><span class="string">2.删除的节点只有一棵子树，</span></span><br><span class="line"><span class="string">3.删除的节点有两棵子树</span></span><br><span class="line"><span class="string">    找出中序立即先行者 即将欲删除节点的左子树中最大者往上提 该节点的左子树往右找 直到右指针指向None</span></span><br><span class="line"><span class="string">    找出中序立即后继者 即将欲删除节点的右子树中最小者往上提 该节点的右子树往左找 直到左指针指向None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h1><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="二叉树的三种遍历方式"><a href="#二叉树的三种遍历方式" class="headerlink" title="二叉树的三种遍历方式"></a>二叉树的三种遍历方式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.res = [[], [], []]</span><br><span class="line">        self.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.res[<span class="number">0</span>].append(root.val)</span><br><span class="line">        self.dfs(root.left)</span><br><span class="line">        self.res[<span class="number">1</span>].append(root.val)</span><br><span class="line">        self.dfs(root.right)</span><br><span class="line">        self.res[<span class="number">2</span>].append(root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote>
<p>题目<br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，<br>    3<br>   / \ <br>  9   20<br>        /  \<br>        15   7</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.val = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 方法一 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    使用递归的方式</span></span><br><span class="line"><span class="string">    :param root:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line"><span class="comment"># 方法二 广度优先搜索</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这里，我们需要添加一个辅助队列。我们将当前层的所有节点都存入这个辅助队列中。</span></span><br><span class="line"><span class="string">在这里需要注意一点，当我们准备搜索下一层时，这里需要将队列中当前层的所有节点都进行出队，然后让这些节点往下层搜索。</span></span><br><span class="line"><span class="string">那么，如果当前层的所有节点都出列，队列还非空，那么说明下一层还有节点。循环直至队列为空，</span></span><br><span class="line"><span class="string">定义变量 depth，每层搜索的时候维护更新该值，那么最终，depth 就是我们要求的二叉树最大深度。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    queue = deque()</span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line"></span><br><span class="line">maxDepth2([<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">15</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    levels = []</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="comment"># 定义队列</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    <span class="comment"># 最终的返回结果</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 先将根节点入队</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment"># 记录当前队列的长度</span></span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment"># 临时列表存储每一层的节点</span></span><br><span class="line">        cur_level = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 出队</span></span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="comment"># 将当前值存储</span></span><br><span class="line">            cur_level.append(node.val)</span><br><span class="line">            <span class="comment"># 当前值的左右节点非空时 入队</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line"></span><br><span class="line">        result.append(cur_level)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="有序数组转化为二叉树"><a href="#有序数组转化为二叉树" class="headerlink" title="有序数组转化为二叉树"></a>有序数组转化为二叉树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</span></span><br><span class="line"><span class="string">  一.若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span></span><br><span class="line"><span class="string">  二.若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span></span><br><span class="line"><span class="string">  三.它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    length = <span class="built_in">len</span>(nums)</span><br><span class="line">    mid = length // <span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[mid])</span><br><span class="line">    root.left = sortedArrayToBST(nums[:mid])</span><br><span class="line">    root.right = sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">print(sortedArrayToBST([-<span class="number">10</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="判断是否为对称二叉树"><a href="#判断是否为对称二叉树" class="headerlink" title="判断是否为对称二叉树"></a>判断是否为对称二叉树</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">给定一个二叉树，检查它是否是镜像对称的。</span></span><br><span class="line"><span class="string"># 递归大法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> auxiliary(root.left, root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auxiliary</span>(<span class="params">leftNode, rightNode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> leftNode.val != rightNode.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> auxiliary(leftNode.left, rightNode.right) <span class="keyword">and</span> auxiliary(leftNode.right, rightNode.left)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>树</category>
      </categories>
      <tags>
        <tag>树结构</tag>
        <tag>二叉树</tag>
        <tag>leetcode</tag>
        <tag>面试题目</tag>
      </tags>
  </entry>
  <entry>
    <title>python之迭代器、生成器、推导式</title>
    <url>/2021/03/04/python%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>python中的基础数据类型都可以进行循环遍历，通常这种对象称为<code>可迭代对象</code>。下面我们回顾一下常用的可迭代对象，<code>set list tuple dict set</code>。那为什么我们称他们为可迭代对象呢?因为他们都遵循了可迭代协议,那什么又是可迭代协议呢.首先我们先看一段代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果:</span></span><br><span class="line"><span class="comment">#a b c</span></span><br><span class="line"><span class="comment">#错误的代码:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">123</span>:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File &quot;D:/python_object/二分法.py&quot;, line 62, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    for i in 123:</span></span><br><span class="line"><span class="comment">#TypeError: &#x27;int&#x27; object is not iterable</span></span><br></pre></td></tr></table></figure>
<p><strong>注意看报错信息,报错信息中有这样一句话: <code>‘int’ object is not iterable </code>翻译过来就是整数类型对象是不可迭代的.</strong><br><code>iterable</code>表示可迭代的。那么如何进行验证你的数据类型是否符合<code>可迭代协议</code>.我们可以通过<code>dir</code>函数来查看类中定义好的所有方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">dir</span>(a)</span><br><span class="line"><span class="comment"># # 在打印结果中寻找__iter__ 如果存在就表示当前的这个类型是个可迭代对象</span></span><br></pre></td></tr></table></figure>
<p>这是查看一个对象是否是可迭代对象的第一种方法，我们还可以通过<code>isinstence()</code>函数来查看一个对象是什么类型的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">l_iter = l.__iter__()</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(l,Iterable)) <span class="comment">#True             #查看是不是可迭代对象</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(l,Iterator)) <span class="comment">#False            #查看是不是迭代器</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(l_iter,Iterator)) <span class="comment">#True       </span></span><br><span class="line">print(<span class="built_in">isinstance</span>(l_iter,Iterable)) <span class="comment">#True</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>__iter__</code>是帮助我们获取到对象的迭代器.我们使用迭代器中的<code>__next__()</code>来获取到一个迭代器的元素,那么我们之前所讲的<code>for循环机制</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;我爱北京天安⻔&quot;</span></span><br><span class="line">c = s.__iter__() <span class="comment"># 获取迭代器</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 使⽤迭代器进⾏迭代. 获取⼀个元素 我</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 爱</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 北</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 京</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 天</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 安</span></span><br><span class="line">print(c.__next__()) <span class="comment"># ⻔</span></span><br><span class="line">print(c.__next__()) <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure>
<p>我们使用while循环和迭代器来模拟for循环: 必须要会</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lslst = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">l = lst.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = l.__next__()</span><br><span class="line">        print(i)</span><br><span class="line">    <span class="keyword">except</span> StopIteration</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p><strong>注意: 迭代器不能反复,只能向下执行,并且是一次性的.获取过了就不能在获取了</strong></p>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p><code>生成器</code>的本质就是<code>迭代器</code>，在python中几种方式来获取生成器</p>
<ul>
<li>通过生成器函数</li>
<li>通过各种推导式实现生成器</li>
</ul>
<h2 id="定义生成器"><a href="#定义生成器" class="headerlink" title="定义生成器"></a>定义生成器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>    </span><br><span class="line">    print(<span class="number">11</span>)    </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">22</span></span><br><span class="line">ret = func()</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 运行结果:&lt;generator object func at 0x000001A575163888&gt;</span></span><br></pre></td></tr></table></figure>
<p>回想下迭代器是怎么使用的,再想想生成器的本质就是迭代器.我们是不是就可以直接使用迭代器的方式直接使用生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>     </span><br><span class="line">    print(<span class="string">&quot;111&quot;</span>)     </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">222</span></span><br><span class="line">gener = func() </span><br><span class="line"><span class="comment"># 这个时候函数不会执⾏. ⽽是获取到⽣成器</span></span><br><span class="line">ret = gener.__next__()</span><br><span class="line"><span class="comment"># 这个时候函数才会执⾏. yield的作⽤和return⼀样. 也是返回数据</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment">#结果:111222</span></span><br></pre></td></tr></table></figure>
<p>那么我们可以看到,yield和return的效果是一样的,但是还是有点区别</p>
<ul>
<li><code>yield</code>是分段来执行一个函数,<code>yield</code>可以出现多次</li>
<li>return是直接停止这个函数,return可以出现多次但是只会执行到第一个就结束了</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>    </span><br><span class="line">	print(<span class="string">&quot;111&quot;</span>)    </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">222</span>    </span><br><span class="line">    print(<span class="string">&quot;333&quot;</span>)   </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">444</span></span><br><span class="line">gener = func()</span><br><span class="line">ret = gener.__next__()</span><br><span class="line">print(ret)</span><br><span class="line">ret2 = gener.__next__()</span><br><span class="line">print(ret2)</span><br><span class="line">ret3 = gener.__next__()</span><br><span class="line"><span class="comment"># 最后⼀个yield执⾏完毕. 再次__next__()程序报错</span></span><br><span class="line">print(ret3)</span><br><span class="line"><span class="comment">#结果:111222333444</span></span><br></pre></td></tr></table></figure>

<h2 id="生成器作用"><a href="#生成器作用" class="headerlink" title="生成器作用"></a>生成器作用</h2><p><strong>生成器的好处是节省内存</strong></p>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式,生成器表达式以及其他推导式,首先我们先看一下这样的代码,给出一个列表,通过循环,想列表中添加1~10:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):    </span><br><span class="line">    li.append(i)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<p>我们换成列表推导式是什么样的,来看看:列表推导式的常⽤写法:<br><strong>[结果 for 变量 in 可迭代对象]</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure>
<p>列表推导式是通过⼀行来构建你要的列表, 列表推导式看起来代码简单. 但是出现错误之后很难排查.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例. 从python1期到python18期写入列表lst:</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&#x27;python%s&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">19</span>)]</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line">lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>) <span class="keyword">if</span> i %<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>

<h2 id="生成器推导式"><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h2><p>生成器表达式和列表推导式的语法基本上一样的,只是把[]换成()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(gen)</span><br><span class="line"><span class="comment"># 结果: &lt;generator object &lt;genexpr&gt; at 0x0000026046CAEBF8&gt;</span></span><br></pre></td></tr></table></figure>
<p>打印的结果就是一个生成器,我们可以使用for循环来循环这个生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = (<span class="string">&quot;第%s次&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen:    </span><br><span class="line">	print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取1-100内能被3整除的数</span></span><br><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> gen:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="comment"># 100以内能被3整除的数的平⽅</span></span><br><span class="line">gen = (i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> gen:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="comment"># 寻找名字中带有两个e的人的名字</span></span><br><span class="line">names = [[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Billy&#x27;</span>, <span class="string">&#x27;Jefferson&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;Wesley&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Jill&#x27;</span>, <span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;Wendy&#x27;</span>, <span class="string">&#x27;Jennifer&#x27;</span>, <span class="string">&#x27;Sherry&#x27;</span>, <span class="string">&#x27;Eva&#x27;</span>]]</span><br><span class="line"><span class="comment"># 不用推导式和表达式</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> first <span class="keyword">in</span> names:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> first:</span><br><span class="line">        <span class="keyword">if</span> name.count(<span class="string">&quot;e&quot;</span>) &gt;= <span class="number">2</span>:</span><br><span class="line">            result.append(name)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 推导式</span></span><br><span class="line">gen = (name <span class="keyword">for</span> first <span class="keyword">in</span> names <span class="keyword">for</span> name <span class="keyword">in</span> first <span class="keyword">if</span> name.count(<span class="string">&#x27;e&#x27;</span>) &gt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p><strong>生成器表达式和列表推导式的区别:</strong></p>
<ul>
<li>列表推导式比较耗内存,一次性加载.生成器表达式几乎不占用内存.使用的时候才分配和使用内存</li>
<li>得到的值不一样,列表推导式得到的是一个列表.生成器表达式获取的是一个</li>
</ul>
<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>根据名字应该也能猜到,推到出来的是字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst1 = [<span class="string">&#x27;jay&#x27;</span>,<span class="string">&#x27;jj&#x27;</span>,<span class="string">&#x27;meet&#x27;</span>]</span><br><span class="line">lst2 = [<span class="string">&#x27;周杰伦&#x27;</span>,<span class="string">&#x27;林俊杰&#x27;</span>,<span class="string">&#x27;郭宝元&#x27;</span>]</span><br><span class="line">dic = &#123;lst1[i]:lst2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst1))&#125;</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>集合推导式可以帮我们直接生成一个集合,集合的特点;无序,不重复 所以集合推导式自带去重功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,-<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">s = &#123;<span class="built_in">abs</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst&#125;</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
        <tag>推导式</tag>
      </tags>
  </entry>
  <entry>
    <title>python之赋值、浅拷贝和深拷贝</title>
    <url>/2021/03/04/python%E4%B9%8B%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>注意：</strong> 结合实际的案例 理解概念</p>
</blockquote>
<h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>在python中，变量的赋值实际就是简单的<code>对象引用</code>，在创建一个对象后，将这个对象赋值给另外一个变量时，python并没有拷贝这个对象，只是拷贝这个对象的引用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义列表alist</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 赋值于变量blist</span></span><br><span class="line">blist = alist</span><br><span class="line"><span class="comment"># 查看alist与blist的内存地址  </span></span><br><span class="line">print(<span class="string">&#x27;alist id = &#x27;</span>, <span class="built_in">id</span>(alist))</span><br><span class="line">print(<span class="string">&#x27;blist id = &#x27;</span>, <span class="built_in">id</span>(blist))</span><br><span class="line"><span class="comment">#alist和blist的内存地址是一样的</span></span><br><span class="line"><span class="comment"># alist id = 1337323184776</span></span><br><span class="line"><span class="comment"># blist id = 1337323184776</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任何修改alist或blist的值，再分别读取</span></span><br><span class="line">print(<span class="string">&#x27;修改alist的值后&#x27;</span>)</span><br><span class="line">alist.append(<span class="string">&#x27;a_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># [1,2,3,&#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1,2,3,&#x27;a_append&#x27;]</span></span><br><span class="line">print(<span class="string">&#x27;修改blist的值后&#x27;</span>)</span><br><span class="line">blist.append(<span class="string">&#x27;b_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># [1,2,3,&#x27;b_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1,2,3,&#x27;b_append&#x27;]</span></span><br><span class="line"><span class="comment"># 修改任意一个list 两者的都发生变化   alist == blist</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>通过<code>copy</code>模块里面的浅拷贝函数<code>copy()</code>，对原始变量指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给新的变量<br>浅拷贝会创建一个对象，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址）</p>
<p><strong>对内部元素影响</strong></p>
<ul>
<li>不可变类型：浅拷贝只是地址指向，不会开辟新空间</li>
<li>可变的数据类型：浅拷贝会开辟新的空间地址(仅仅是顶层开辟了新的空间，里层的元素地址还是一样的)，进行浅拷贝</li>
<li>浅拷贝后，改变原始对象中可变类型元素的值，会同时影响拷贝对象，改变原始对象中不可变类型元素的值，只有原始类型受影；操作拷贝对象对原始对象的也是同理</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="comment">#定义alist，并拷贝给blist</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">blist = alist.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist 与 blist内存地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist的地址分别为&#x27;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(alist))</span><br><span class="line">print(<span class="built_in">id</span>(blist))</span><br><span class="line"><span class="comment"># alist与blist的地址分别为</span></span><br><span class="line"><span class="comment"># 2056373019592</span></span><br><span class="line"><span class="comment"># 2056373060616</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist与blist内元素的地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist内元素的地址分别为&#x27;</span>)</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> alist])</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> blist])</span><br><span class="line"><span class="comment"># alist与blist内元素的地址分别为</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 2056373019336]</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 2056373019336]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist的内元素的值&#x27;</span>)</span><br><span class="line">alist.append(<span class="string">&#x27;a_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># 修改alist的内元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8]]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist中的列表元素的值&#x27;</span>)</span><br><span class="line">alist[<span class="number">3</span>].append(<span class="string">&#x27;a_second_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment">#修改alist中的列表元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8, &#x27;a_second_append&#x27;], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8, &#x27;a_second_append&#x27;]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>通过<code>copy</code>模块里面的深拷贝函数<code>deepcopy()</code>，对原始变量指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给新的变量.跟浅拷贝类似，深拷贝也会创建一个新的对象</p>
<blockquote>
<p>对于对象中的元素，深拷贝都会重新生成一份，而不是简单的使用原始元素的引用（内存地址）<br>经过深拷贝后，原始对象和拷贝对象所有的子元素地址都是独立的了</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义alist，并深度拷贝给blist</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">blist = copy.deepcopy(alist)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist 与 blist内存地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist的地址分别为&#x27;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(alist))</span><br><span class="line">print(<span class="built_in">id</span>(blist))</span><br><span class="line"><span class="comment"># alist与blist的地址分别为</span></span><br><span class="line"><span class="comment"># 2612203103176</span></span><br><span class="line"><span class="comment"># 2612203144200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist与blist内元素的地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist内元素的地址分别为&#x27;</span>)</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> alist])</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> blist])</span><br><span class="line"><span class="comment"># alist与blist内元素的地址分别为</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 1993019826888]</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 1993020930824]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist的内元素的值&#x27;</span>)</span><br><span class="line">alist.append(<span class="string">&#x27;a_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># 修改alist的内元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8]]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist中的列表元素的值&#x27;</span>)</span><br><span class="line">alist[<span class="number">3</span>].append(<span class="string">&#x27;a_second_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># 修改alist中的列表元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8, &#x27;a_second_append&#x27;], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8]]</span></span><br></pre></td></tr></table></figure>

<p><strong>最后附图一张，便于理解：</strong> <a href="https://blog.csdn.net/colourful_sky/article/details/81263998?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.not_use_machine_learn_pai">点击查看图源…</a></p>
<p><img src="https://img-blog.csdnimg.cn/20201210091158136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片描述"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
        <tag>深浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>详谈python中的几个高阶函数</title>
    <url>/2021/03/03/%E8%AF%A6%E8%B0%88python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>详谈python的sort、sorted、map、filter、reduce 函数</strong></p>
<h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><p><code>sort()</code>函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。<code>list.sort(key=None, reverse=False)</code></p>
<ul>
<li>key:主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li>
<li>reverse:排序规则，reverse = True 降序， reverse = False 升序（默认）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>) <span class="comment"># 按照元祖的第二个元素排序（降序）</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [(3, 4), (1, 3), (2, 2), (4, 1)]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h1><ul>
<li><p>对列表排序,返回的对象不会改变原列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 7]</span></span><br><span class="line"><span class="comment">#可以设定时候排序方式，默认从小到大，设定reverse = False 可以从大到小</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">list</span>,reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 7]</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">list</span>,reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># [7, 5, 4, 2, 1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自定义规则来排序，使用参数：key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用key,默认搭配lambda函数使用</span></span><br><span class="line"><span class="built_in">sorted</span>(chars,key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x))</span><br><span class="line"><span class="comment">#[&#x27;a&#x27;, &#x27;is&#x27;, &#x27;boy&#x27;, &#x27;bruce&#x27;, &#x27;handsome&#x27;]</span></span><br><span class="line"><span class="built_in">sorted</span>(chars,key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse= <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#[&#x27;handsome&#x27;, &#x27;bruce&#x27;, &#x27;boy&#x27;, &#x27;is&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自定义规则来排序，对元组构成的列表进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple_list = [(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>,<span class="number">5</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>,<span class="number">2</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">2</span>,<span class="number">6</span>)]</span><br><span class="line"><span class="comment">#key=lambda x: x[1]中可以任意选定x中可选的位置进行排序</span></span><br><span class="line"><span class="built_in">sorted</span>(tuple_list, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) </span><br><span class="line"><span class="comment">#[(&#x27;A&#x27;, 1, 5), (&#x27;C&#x27;, 2, 6), (&#x27;B&#x27;, 3, 2)]</span></span><br><span class="line"><span class="built_in">sorted</span>(tuple_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#[(&#x27;A&#x27;, 1, 5), (&#x27;B&#x27;, 3, 2), (&#x27;C&#x27;, 2, 6)]</span></span><br><span class="line"><span class="built_in">sorted</span>(tuple_list, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>])</span><br><span class="line"><span class="comment">#[(&#x27;B&#x27;, 3, 2), (&#x27;A&#x27;, 1, 5), (&#x27;C&#x27;, 2, 6)]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>python的<code>map</code>函数使得函数能直接以list的每个元素作为参数传递到<code>funcname</code>中, 并返回响应的新的<code>list</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sq</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">return</span> x*x <span class="comment">#求x的平方</span></span><br><span class="line"><span class="built_in">map</span>(sq, [<span class="number">1</span>,<span class="number">3</span>, <span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#[1, 9, 25, 49, 81]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h1><p><code>filter(function or None, iterable)</code>执行过程依次将list中的元素传递到funcname函数中, 根据funcname返回的True或False 保留或丢弃元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_int</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>)):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">filter</span>(is_int, [<span class="string">&quot;Yi&quot;</span>,<span class="number">2</span>, <span class="string">&quot;3&quot;</span>, <span class="number">4</span>]) <span class="comment">#[2, 4]</span></span><br></pre></td></tr></table></figure>

<h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h1><p>与map相比 , reduce类似于一个聚合类的应用方法, 把list中的参数, 依次传递给funcname, 每次funcname的参数都是上个funcname 执行结果和下一个list中的元素, 所以, funcname 的 参数必须是两个. 从执行过程看, 有点像递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#例如: 求range(1, 101)(不包括101)的和,</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">reduce(c_sum, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>)) <span class="comment">#5050</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
        <tag>高阶函数</tag>
      </tags>
  </entry>
  <entry>
    <title>python垃圾回收机制</title>
    <url>/2021/03/03/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>你哈</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python进阶</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础篇—语法</title>
    <url>/2021/03/03/python%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><p>整形就是十进制整数的统称。<a href="https://blog.csdn.net/qq_36581961/article/details/110467300">https://blog.csdn.net/qq_36581961/article/details/110467300</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">number = <span class="number">99</span></span><br><span class="line">print(<span class="built_in">type</span>(number)) <span class="comment"># 查看类型</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>字符串就是平时用来表示文本信息。<a href="https://blog.csdn.net/qq_36581961/article/details/110517151">https://blog.csdn.net/qq_36581961/article/details/110517151</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;我是字符串-单引号&#x27;</span></span><br><span class="line">s2 = <span class="string">&quot;我是字符串-双引号&quot;</span></span><br><span class="line">s3 = <span class="string">&#x27;&#x27;&#x27;我是用来多行或者换行表示字符串-单引号&#x27;&#x27;&#x27;</span></span><br><span class="line">s4 = <span class="string">&quot;&quot;&quot;我是用来多行或者换行表示字符串-双引号&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断字符串以xx开头 返回布尔值</span></span><br><span class="line">s = <span class="string">&quot;tmd 烦死了&quot;</span></span><br><span class="line">result = s.startwith(<span class="string">&#x27;tmd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串以xx结尾 返回布尔值</span></span><br><span class="line">s = <span class="string">&#x27;生命最将会结束&#x27;</span></span><br><span class="line">result = s.endwith(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否为十进制数字 返回布尔值</span></span><br><span class="line">s = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">result = s.isdecimal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除空格</span></span><br><span class="line">s = <span class="string">&#x27;  我的是liuwangleo   &#x27;</span></span><br><span class="line">s.strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串大小写转换</span></span><br><span class="line">s = <span class="string">&#x27;Hello World LEO&#x27;</span></span><br><span class="line">su = s.upper()</span><br><span class="line">sl = su.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容替换</span></span><br><span class="line">s = <span class="string">&#x27;祝你幸福，你要好好的&#x27;</span></span><br><span class="line">s.replace(<span class="string">&#x27;你&#x27;</span>，<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符出切割</span></span><br><span class="line">s = <span class="string">&#x27;1,2,3,4,5&#x27;</span></span><br><span class="line">s.split(<span class="string">&#x27;,&#x27;</span>)  <span class="comment"># [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 注意 加第二参数时 </span></span><br><span class="line">s.split(<span class="string">&#x27;,&#x27;</span>,<span class="number">2</span>)  <span class="comment"># 分割次数 默认为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;-&#x27;</span>.join(l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串</span></span><br><span class="line"><span class="comment"># %s</span></span><br><span class="line"><span class="comment"># format</span></span><br><span class="line">s1 = <span class="string">&quot;我喜欢&#123;0&#125;、&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">s2 = <span class="string">&quot;我喜欢%s、%s&quot;</span> % (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转换</span></span><br><span class="line">s = <span class="built_in">str</span>(<span class="number">1111</span>)</span><br><span class="line"><span class="built_in">type</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取长度</span></span><br><span class="line">s = <span class="string">&#x27;我有多长&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这部分建议去shell里测试一下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 索引 重要 *</span></span><br><span class="line">s = <span class="string">&#x27;1234,木头人@leo&#x27;</span></span><br><span class="line">s[<span class="number">0</span>]</span><br><span class="line">s[<span class="built_in">len</span>(s)-<span class="number">1</span>]</span><br><span class="line">s[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">s = <span class="string">&#x27;liuwangleo.github.io&#x27;</span></span><br><span class="line">s[<span class="number">0</span>:]</span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">s[:-<span class="number">1</span>]</span><br><span class="line">s[-<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长 </span></span><br><span class="line">s = <span class="string">&quot;生活不是电影，生活比电影苦&quot;</span></span><br><span class="line">s[::<span class="number">2</span>]</span><br><span class="line">s[<span class="number">2</span>::<span class="number">2</span>]</span><br><span class="line">s[::-<span class="number">1</span>]  <span class="comment">#倒序</span></span><br><span class="line">s[<span class="number">1</span>:<span class="number">3</span>:-<span class="number">1</span>]  <span class="comment"># 报错</span></span><br><span class="line">s[<span class="number">3</span>:<span class="number">1</span>:-<span class="number">1</span>]  <span class="comment"># &#x27;是不&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>可以把列表当做是一个有序的容器，在里面可以放很多的元素。<a href="https://blog.csdn.net/qq_36581961/article/details/110517411">https://blog.csdn.net/qq_36581961/article/details/110517411</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 追加 </span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">data.append(<span class="string">&#x27;字符串混入&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">data.insert(<span class="number">0</span>,<span class="string">&#x27;0a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展</span></span><br><span class="line">data = [<span class="string">&#x27;嗯&#x27;</span>,<span class="string">&#x27;哦&#x27;</span>]</span><br><span class="line">data.extend([<span class="string">&#x27;啊&#x27;</span>,<span class="string">&#x27;哈&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据值移除</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.remove(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">data.remove(<span class="string">&#x27;q&#x27;</span>) <span class="comment"># 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引删除</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.pop()</span><br><span class="line">data.pop(<span class="number">1</span>) <span class="comment"># 删除索引未2的值 倒数第二个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转列表</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.reverse()</span><br></pre></td></tr></table></figure>

<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取长度</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line"><span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[<span class="number">0</span>]</span><br><span class="line">data[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[-<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">data[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[<span class="number">0</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>元组也是一个容器，里面可以存放各种数据（和列表相似），但他有一个特殊的特点：元组的儿子元素不允许添加、不允许修改、不允许删除，只能读。<a href="https://blog.csdn.net/qq_36581961/article/details/110621604">https://blog.csdn.net/qq_36581961/article/details/110621604</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,)</span><br><span class="line">t3 = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">t3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 面试题</span></span><br><span class="line"><span class="string">1. 比较值 v1 = (1) 和 v2 = 1 和 v3 = (1,) 有什么区别？</span></span><br><span class="line"><span class="string">2. 比较值 v1 = ((1),(2),(3)) 和 v2 = ((1,),(2,),(3,),) 有什么区别？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元组和列表十分相似 但由于元组的子元素无法修改的特点，</span></span><br><span class="line"><span class="string">所有在元组都没有修改、删除、添加的操作，只有读操作。</span></span><br><span class="line"><span class="string">所以 这部分参考列表就可以。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>字典也可以当做是个容器，在内部可以存放数据。相比较于元组和列表，字典的元素必须是<code>键值对</code><br><a href="https://blog.csdn.net/qq_36581961/article/details/110621888">https://blog.csdn.net/qq_36581961/article/details/110621888</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>, <span class="string">&quot;name&quot;</span>:<span class="string">&quot;11&quot;</span>,<span class="string">&quot;hobby&quot;</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]&#125;<span class="comment"># 例如： &quot;age&quot;:12 称为一个键值对。</span></span><br><span class="line">d = &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：字典的键有特殊要求，即：必须可哈希 。 目前为止学到的可哈希的类型：int/bool/str/tuple；不可哈希的类型：list/dict</p>
</blockquote>
<h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>, <span class="string">&quot;name&quot;</span>:<span class="string">&quot;11&quot;</span>,<span class="string">&quot;hobby&quot;</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有键</span></span><br><span class="line">info.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有值</span></span><br><span class="line">info.values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键值</span></span><br><span class="line">info.items()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新字典键值对</span></span><br><span class="line">info.update(&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">13</span>&#125;) <span class="comment">## info中没有的键直接添加；有的键则更新值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除字典的键值对</span></span><br><span class="line">info.pop(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据键获取值</span></span><br><span class="line">info.get(<span class="string">&#x27;name&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>集合与元组和列表相似都用于做容器，在内部可以放一些子元素，但集合有三特殊特点： 子元素不重复 、 子元素必须可哈希、无序.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">99</span>,<span class="number">18</span>&#125;</span><br><span class="line">v2 = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;Ee&quot;</span>&#125;</span><br><span class="line">v3 = &#123;<span class="number">1</span>,<span class="literal">True</span>,<span class="string">&quot;world&quot;</span>,(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">data.add(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">data.discard(<span class="string">&#x27;c&#x27;</span>) <span class="comment">#不存在不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125; </span><br><span class="line">s2 = &#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125; </span><br><span class="line">s3 = s1 &amp; s2   <span class="comment"># 方式一：取两个集合的交集 </span></span><br><span class="line">s4 = s1.intersection(s2)) <span class="comment"># 方式二：取两个集合的交集</span></span><br><span class="line">print(s3,s4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125; </span><br><span class="line">s2 = &#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;&#125; </span><br><span class="line">s3 = s1 | s2               <span class="comment"># 方式一：取两个集合的并集 </span></span><br><span class="line">s4 = s1.union(s2))         <span class="comment"># 方式二：取两个集合的并集 </span></span><br><span class="line">print(s3,s4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;刘能&quot;</span>, <span class="string">&quot;赵四&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125; </span><br><span class="line">s2 = &#123;<span class="string">&quot;刘科⻓&quot;</span>, <span class="string">&quot;冯乡⻓&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125; </span><br><span class="line">s3 = s1 - s2                       <span class="comment"># 方式一：差集，s1中有且s2中没有的值 </span></span><br><span class="line">s4 = s1.difference(s2)         <span class="comment"># 方式二：差集，s1中有且s2中没有的值 </span></span><br><span class="line">print(s3,s4) </span><br><span class="line">s5 = s2 - s1                     <span class="comment"># 方式一：差集，s2中有且s1中没有的值 </span></span><br><span class="line">s6 = s2.difference(s1)           <span class="comment"># 方式一：差集，s2中有且s1中没有的值 </span></span><br><span class="line">print(s5,s6)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟环境详细介绍</title>
    <url>/2021/03/02/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><h2 id="为什么要使用虚拟环境"><a href="#为什么要使用虚拟环境" class="headerlink" title="为什么要使用虚拟环境"></a>为什么要使用虚拟环境</h2><p>到目前位置，我们所有的第三方包安装都是直接通过<strong>pip install</strong>的方式进行安装的，这样安装会将那个包安装到你的系统级的<strong>python</strong>环境中。但是这样有一个问题，就是如果你现在用<strong>Django2.0</strong>写了个网站，然后你的领导跟你说，之前有一个旧项目是用<strong>Django1.0</strong>开发的，让你来维护，但是不再兼容<strong>Django1.0和Django2.0</strong>的一些语法了。这时候就会碰到一个问题，我如何在我的电脑中同时拥有<strong>Django1.0和Django2.0</strong>两套环境呢？这时候我们就可以通过虚拟环境来解决这个问题。</p>
<h2 id="虚拟环境原理介绍"><a href="#虚拟环境原理介绍" class="headerlink" title="虚拟环境原理介绍"></a>虚拟环境原理介绍</h2><p>虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于<strong>Django1.0</strong>版本，又有一个项目是基于<strong>Django2.0</strong>的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装<strong>Django1.0和Django2.0</strong>来适配我们的项目。</p>
<h2 id="虚拟环境的使用"><a href="#虚拟环境的使用" class="headerlink" title="虚拟环境的使用"></a>虚拟环境的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>pip install virtualenv </p>
<p>pip3 install virtualenv </p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>virtualenv [虚拟环境的名称] </p>
<p>如果你当前的<strong>python3</strong>的查找路径在<strong>python2</strong>的前面，那么将会使用<strong>python3</strong>作为这个虚拟环境的解释器。如果<strong>python2</strong>在<strong>python3</strong>前面，那么将会使用<strong>python3</strong>来作为这个虚拟环境的解释器.</p>
<p><strong>创建虚拟环境的时候指定python解释器</strong></p>
<p>virtualenv -p “python安装路径” [虚拟环境名称] </p>
<h3 id="进入环境"><a href="#进入环境" class="headerlink" title="进入环境"></a>进入环境</h3><p>虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是Windows，第二种是*nix：</p>
<p>windows进入虚拟环境：进入到虚拟环境的Scripts文件夹中，然后执行activate。</p>
<p>*nix进入虚拟环境：source /path/to/virtualenv/bin/activate</p>
<p>一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。</p>
<h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><p>deactivate</p>
<h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>linux:pip install virtualenvwrapper<br>windows: pip install virtualenvwrapper-win </p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>1.创建虚拟环境 mkvirtualenv [虚拟环境名称] 
2.切换虚拟环境 workon [虚拟环境名称] 
3.退出虚拟环境 deactivate 
4.删除某个虚拟环境 rmvirtualenv [虚拟环境名称] 
5.列出虚拟环境 lsvirtualenv 
</code></pre>
<h3 id="修改mkvirtualenv的默认路径"><a href="#修改mkvirtualenv的默认路径" class="headerlink" title="修改mkvirtualenv的默认路径"></a>修改mkvirtualenv的默认路径</h3><p>在我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量中添加一个参数WORKON_HOME，将这个参数的值设置为你需要的路径。</p>
<h3 id="创建虚拟环境的时候指定Python版本"><a href="#创建虚拟环境的时候指定Python版本" class="headerlink" title="创建虚拟环境的时候指定Python版本"></a>创建虚拟环境的时候指定Python版本</h3><p>在使用mkvirtualenv的时候，可以指定–python的参数来指定具体的python路径：</p>
<p>mkvirtualenv –python==C:\Python36\python.exe hy_env </p>
<h3 id="window配置环境变量"><a href="#window配置环境变量" class="headerlink" title="window配置环境变量"></a>window配置环境变量</h3><p>在环境变量里边添加 <strong>WORKON_HOME = “本地的目录”</strong></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>virtualenv</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title>详解MySQL-InnoDB中索引与算法</title>
    <url>/2021/03/01/%E8%AF%A6%E8%A7%A3MySQL-InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>索引在应用程序设计和开发中是一个重要的方面。往往实际开发中部分工程师对其重视或认知程度不足，忽略索引的重要性，导致要么不用索引，要么滥用索引，这样都会对系统性能产生影响。博主对索引这部分知识进行了总结和归纳，其中也附加自己的认知，分享给大家一起讨论和理解。</p>
<h2 id="为何用索引"><a href="#为何用索引" class="headerlink" title="为何用索引"></a>为何用索引</h2><p>大家仔细想想是不是大部分的系统<code>读</code>占比很大，而且在生产环境中，最容易出问题也是复杂的查询操作，这都是源自于一条条的<code>SQL</code>，SQL优化就成为重中之重，这其中索引起到非常关键作用。</p>
<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引在MySQL中也叫做<code>“键”或者&quot;key&quot;</code>（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。<br><strong>强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据</strong></p>
<h2 id="索引的认知"><a href="#索引的认知" class="headerlink" title="索引的认知"></a>索引的认知</h2><p>站在开发者的角度：<code>在系统设计之初就要考虑索引的设计</code></p>
<h1 id="认识索引"><a href="#认识索引" class="headerlink" title="认识索引"></a>认识索引</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>​索引的目的在于<code>提高查询效率</code>，结合生活中的案例，其实与查阅图书是一个道理：<code>先定位到章，然后定位到该章下的一个小节，然后找到页数</code>。相似的例子还有：查字典，查火车车次，飞机航班等。仔细思考，书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。你再想，你在没有数据的情况下先建索引或者说目录快，还是已经存在好多的数据了，然后再去建索引，哪个快，肯定是没有数据的时候快，因为如果已经有了很多数据了，你再去根据这些数据建索引，是不是要将数据全部遍历一遍，然后根据数据建立索引。你再想，索引建立好之后再添加数据快，还是没有索引的时候添加数据快，索引是用来干什么的，是用来加速查询的，那对你写入数据会有什么影响，肯定是慢一些了，因为你但凡加入一些新的数据，都需要把索引或者说书的目录重新做一个，所以索引虽然会加快查询，但是会降低写入的效率。</p>
<h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ul>
<li>在表中有大量数据的前提下，创建索引速度会很慢</li>
<li>在索引创建完毕后，对表的查询性能会大幅度提升，但是写性能会降低</li>
</ul>
<p><strong>本质：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</strong></p>
<p>数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<h2 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h2><p>​前面提到了<code>访问磁盘</code>，那么这里先简单介绍一下<code>磁盘IO</code>和<code>预读</code>。磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<code>寻道时间</code>、<code>旋转延迟</code>、<code>传输时间</code>三个部分，<strong>寻道时间指的是磁臂移动到指定磁道所需要的时间</strong>，主流磁盘一般在5ms以下；<strong>旋转延迟就是我们经常听说的磁盘转速</strong>，比如一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了，还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；<strong>传输时间指的是从磁盘读出或将数据写入磁盘的时间</strong>，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。</p>
<h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>在此之前我们先简单了解一下InnoDB存储引擎支持的索引，InnoDB存储引擎支持以下几种常见的索引：</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<p>B+树索引是关系型数据库中查找最为常用和最为有效的索引。其中涉及很多的算法和数据结构，先认识一下相关的知识，这更加有助于我们理解B+树的工作方式。</p>
<h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>也称其为<code>折半查找法</code>，前提是数据已经是有序的状态，将数据分割成两等份，再比较键值与中间值的大小，如果键值小于中间值，确定查找的数据在前半段，否则在后半段。通过一次次的比较，将查找区间缩小一半。时间复杂度为O(logn)。<br>代码实现：<a href="https://blog.csdn.net/qq_36581961/article/details/112203684">https://blog.csdn.net/qq_36581961/article/details/112203684</a></p>
<h2 id="二叉查找树、红黑树和平衡二叉树"><a href="#二叉查找树、红黑树和平衡二叉树" class="headerlink" title="二叉查找树、红黑树和平衡二叉树"></a>二叉查找树、红黑树和平衡二叉树</h2><p><strong>二叉查找树</strong>：<br>在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，具体的实现过程可以参考<a href="https://www.cs.usfca.edu/~galles/visualization/BST.html">https://www.cs.usfca.edu/~galles/visualization/BST.html</a>。二叉查找树可以任意构造，当出现递增的情况，查找的次数回提高，和顺序查找差不多，类似于链表，这时查询效率降低。</p>
<p><strong>红黑树</strong>：<br>构建过程可以参考<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a>，在JDK1.8中HashMap底层使用就是红黑树，它的特点就是有<code>自旋</code>的功能，能够避免出现二叉查找树中递增的现象。但是当数据量过大时，会造成树的高度过高，也会降低查询效率。</p>
<p><strong>平衡二叉树</strong><br><code>定义：首先要符合二叉树的定义，其次必须满足任何节点的两个子树的高度最大差为1。</code>实现过程<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a>，平衡二叉树的查询速度很快，但是维护一棵平衡二叉树的代价是比较大的，因为需要大量的旋转操作。</p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><blockquote>
<p><strong>关于b+树的定义</strong>：B+树是为磁盘或其他直接存取辅助设备设计的一种<code>平衡查找树</code>，在B+树中，所有记录节点都是按键值的大小存放在同一层的叶子节点上，由个叶子节点指针进行连接。(这只是精简介绍，具体内容可以自行百度)</p>
</blockquote>
<p>​如图：<a href="https://coding-net-production-file-ci.codehub.cn/12c73320-1acb-11eb-ae87-97fbb992c8dd.png?sign=+YTZUdgyVbT160JiSrw7S15tnIZhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNjE0NDM1OTk4JnQ9MTYxNDIxOTk5OCZyPTY4OTk2NzEwJmY9LzEyYzczMzIwLTFhY2ItMTFlYi1hZTg3LTk3ZmJiOTkyYzhkZC5wbmcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==">点击查看图片</a>，是一颗b+树，最上层是树根，中间的是树枝，最下面是叶子节点。</p>
<p>如上图：浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容，一个块对应3个扇区，可以看到每个磁盘块包含几个数据项（深蓝色所示，一个磁盘块里面包含多少数据，一个深蓝色的块表示一个数据，其实不是数据，后面有解释）和指针（黄色所示，看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<blockquote>
<p><strong>b+树的查找过程</strong>：如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。</p>
</blockquote>
<blockquote>
<p><strong>b+树性质</strong></p>
<ul>
<li><p>索引字段要尽量的小<br> ​通过上面的分析，我们知道IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<strong>h=㏒(m+1)N</strong>，当数据量N一定的情况下，m越大，h越小；而<strong>m = 磁盘块的大小 / 数据项的大小</strong>，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
</li>
<li><p>索引的最左匹配特性<br>简单来说就是你的数据来了以后，从数据块的左边开始匹配，在匹配右边的，知道这句话就行啦~~~~，我们继续学下面的内容。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
</li>
</ul>
</blockquote>
<h1 id="聚集索引和辅助索引"><a href="#聚集索引和辅助索引" class="headerlink" title="聚集索引和辅助索引"></a>聚集索引和辅助索引</h1><p>还记得MyISAM存储引擎在创建表的时候会在硬盘上生成哪些文件吗，是不是有三个<code>.frm.MYD.MYI</code>结尾的三个文件，<strong>frm结尾的是表结构，MYD结尾的是数据文件，MYI结尾的就是索引文件</strong>，也就是说索引也是存在硬盘上的，那InnoDB引擎呢，创建一个表，在硬盘上会生成<code>.frm.idb</code> 结尾的两个文件，那索引的呢，难道InnoDB就用不了索引吗？怎么可能？之前咱们有没有建立过索引啊，primary key、unique key是不是都叫做索引啊，但是索引那个文件去哪了呢，索引是不可能在表结构.frm（存什么字段什么类型这些东西）的文件中，那就只剩下<code>.idb</code>结尾的数据文件了，索引就在这里面，InnoDB引擎的表，它的<strong>索引和数据都在同一个文件里面</strong>，所以一直强调，使用InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据或者说方式。</p>
<p>也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。这种索引，我们就称为<code>聚集索引</code>，也就是在聚集数据组织数据的时候，就用这种索引。InnoDB这么做就是为了加速查询效率，因为你经常会遇到基于主键来查询数据的情况，并且通常我们把id字段作为主键，第一点是因为id占用的数据空间不大，第二点是你经常会用到id来查数据。如果你的表有两个字段，一个id一个name，id为主键，当你查询的时候如果where后面的条件是name=多少多少，那么你就没有用到主键给你带来的加速查询的效果（需要主键之外的辅助索引），如果你用where id=多少多少，就会按照我们刚才上面说的哪种树形结构来给你找寻数据了（当然不仅仅有这种树形结构的数据结构类型），能够快速的帮你定位到数据块。这种聚集索引的特点是它会以id字段作为依据，去建立树形结构，但是叶子节点存的是你表中的一条完整记录，一条完整的数据。记住这一点昂，<code>辅助索引</code>和这个内容有关系，会讲到一个<code>回表</code>的概念。</p>
<hr>
<p>​在数据库中，B+树的高度一般都在2-4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2-4次的IO意味着查询时间只需要0.02~0.04秒。</p>
<p>数据库中的B+树索引可以分为<strong>聚集索引</strong>（clustered index）和<strong>辅助索引</strong>（secondary index），聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，<strong>叶子结点存放着所有的数据</strong>。聚集索引与辅助索引不同的是：<strong>叶子结点存放的是否是一整行的信息</strong></p>
<h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>​InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而<code>聚集索引</code>（clustered index）就是按照每张表的主键构造一棵B+树，同时<code>叶子结点存放的即为整张表的行记录数据</code>，也将聚集索引的叶子结点称为<code>数据页</code>。</p>
<p>聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。 如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为<code>聚簇索引</code>。如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有<code>六个字节</code>，而且是隐藏的，使其作为<code>聚簇索引</code>。 由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</p>
<p><strong>聚集索引的优点</strong><br>它对主键的<code>排序查找</code>速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录；<code>范围查询</code>（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可</p>
<h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>表中除了聚集索引外其他索引都是<code>辅助索引</code>（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：<strong>辅助索引的叶子节点不包含行记录的全部数据</strong>。</p>
<p>​叶子节点存放的是对应的那条数据的主键字段的值，除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark），其实这个书签你可以理解为是一个{‘name字段’，name的值，主键id值}的这么一个数据。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。如果我们<strong>select 后面要的是name</strong>，我们直接就可以在<strong>辅助索引的叶子节点找到对应的name值</strong>，比如：select name from tb1 where name=’xx’；这个xx值你直接就在辅助索引的叶子节点就能找到，这种我们也可以称为<code>[覆盖索引]</code>。如果你select后面的字段不是name，例如：select age from tb1 where name=’xx’；也就是说，我通过辅助索引的叶子节点不能直接拿到age的值，需要通过辅助索引的叶子节点中保存的主键id的值再去通过聚集索引来找到完整的一条记录，然后从这个记录里面拿出age的值，这种操作有时候也成为<code>[回表查询]</code>，就是从头再回去查一遍，这种的查询效率也很高，但是比覆盖索引低一些，再说一下昂，再辅助索引的叶子节点就能找到你想找的数据可称为[覆盖索引]。</p>
<h1 id="联合索引和索引覆盖"><a href="#联合索引和索引覆盖" class="headerlink" title="联合索引和索引覆盖"></a>联合索引和索引覆盖</h1><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引时指<strong>对表上的多个列合起来做一个索引</strong>，省的你查询的时候，where后面的条件字段一直再变，你就想给每个字段加索引的尴尬问题。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列.</p>
<p><strong>注意建立联合索引的一个原则：</strong> 索引是有个<code>最左匹配的原则</code>的，所以建联合索引的时候，将区分度高的放在最左边，依次排下来，范围查询的条件尽可能的往后边放。</p>
<p><strong>联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理，</strong> 例如在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以帮我们避免多一次的排序操作，因为索引本身在叶子节点已经排序了</p>
<h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。</p>
<p>使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作</p>
<p><strong>注意：覆盖索引技术最早是在InnoDB Plugin中完成并实现，这意味着对于InnoDB版本小于1.0的，或者MySQL数据库版本为5.0以下的，InnoDB存储引擎不支持覆盖索引特性</strong></p>
<p>对于InnoDB存储引擎的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为（primary key1，priamey key2，…,key1，key2，…）</p>
<h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">普通索引INDEX：加速查找 </span><br><span class="line">	唯一索引：</span><br><span class="line">        -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复） </span><br><span class="line">        -唯一索引UNIQUE:加速查找+约束（不能重复） </span><br><span class="line">	联合索引： </span><br><span class="line">		-PRIMARY KEY(<span class="built_in">id</span>,name):联合主键索引 </span><br><span class="line">        -UNIQUE(<span class="built_in">id</span>,name):联合唯一索引 </span><br><span class="line">        -INDEX(<span class="built_in">id</span>,name):联合普通索引</span><br><span class="line">索引操作：</span><br><span class="line">	添加主键索引:</span><br><span class="line">	创建的时候添加:添加索引的时候要注意,给字段里面数据大小比较小的字段添加,给字段里面的数据区分度高的字段添加.</span><br><span class="line">聚集索引的添加方式</span><br><span class="line">	创建的是添加</span><br><span class="line">        Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span> primary key,</span><br><span class="line">        )</span><br><span class="line">        Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span>,</span><br><span class="line">        Primary key(<span class="built_in">id</span>)</span><br><span class="line">        )</span><br><span class="line">	表创建完了之后添加</span><br><span class="line">		Alter table 表名 add primary key(<span class="built_in">id</span>)</span><br><span class="line">	删除主键索引:</span><br><span class="line">		Alter table 表名 drop primary key;</span><br><span class="line">	</span><br><span class="line">	唯一索引:</span><br><span class="line">        Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span> unique,</span><br><span class="line">        )</span><br><span class="line">            Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span>,</span><br><span class="line">        Unique key uni_name (<span class="built_in">id</span>)</span><br><span class="line">        )</span><br><span class="line">		表创建好之后添加唯一索引:</span><br><span class="line">			alter table s1 add unique key  u_name(<span class="built_in">id</span>);</span><br><span class="line">    	删除:</span><br><span class="line">    		Alter table s1 drop index u_name;</span><br><span class="line">    	</span><br><span class="line">	普通索引:</span><br><span class="line">        创建:</span><br><span class="line">            Create table t1(</span><br><span class="line">            Id <span class="built_in">int</span>,</span><br><span class="line">            Index index_name(<span class="built_in">id</span>)</span><br><span class="line">            )</span><br><span class="line">            Alter table s1 add index index_name(<span class="built_in">id</span>);</span><br><span class="line">            Create index index_name on s1(<span class="built_in">id</span>);</span><br><span class="line">        删除:</span><br><span class="line">            Alter table s1 drop index u_name;</span><br><span class="line">            DROP INDEX 索引名 ON 表名字;</span><br><span class="line">	举个例子来说，比如你在为某商场做一个会员卡的系统。 这个系统有一个会员表 有下列字段： </span><br><span class="line">		会员编号 INT </span><br><span class="line">		会员姓名 VARCHAR(<span class="number">10</span>) </span><br><span class="line">		会员身份证号码 VARCHAR(<span class="number">18</span>) </span><br><span class="line">		会员电话 VARCHAR(<span class="number">10</span>) </span><br><span class="line">		会员住址 VARCHAR(<span class="number">50</span>) </span><br><span class="line">		会员备注信息 TEXT</span><br><span class="line">	那么这个 </span><br><span class="line">		会员编号，作为主键，使用 PRIMARY </span><br><span class="line">		会员姓名 如果要建索引的话，那么就是普通的 INDEX </span><br><span class="line">		会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）</span><br><span class="line">	<span class="comment">#除此之外还有全文索引，即FULLTEXT </span></span><br><span class="line">		会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。 </span><br><span class="line">		用于搜索很长一篇文章的时候，效果最好。 </span><br><span class="line">		用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。 </span><br><span class="line">		但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。 </span><br><span class="line"><span class="comment">#其他的如空间索引SPATIAL，了解即可，几乎不用</span></span><br></pre></td></tr></table></figure>

<h1 id="正确使用索引"><a href="#正确使用索引" class="headerlink" title="正确使用索引"></a>正确使用索引</h1><ul>
<li><p>范围问题，或者说条件不明确，条件中出现这些符号或关键字：**&gt;、&gt;=、&lt;、&lt;=、!= 、between…and…、like、大于号、小于号</p>
</li>
<li><p>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p>
</li>
<li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
</li>
<li><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)</p>
</li>
<li><p>and/or</p>
<blockquote>
<p>#1、and与or的逻辑 条件1 and 条件2:所有条件都成立才算成立，但凡要有一个条件不成立则最终结果不成立 条件1 or 条件2:只要有一个条件成立则最终结果就成立 </p>
<p>#2、and的工作原理 条件： a = 10 and b = ‘xxx’ and c &gt; 3 and d =4 索引： 制作联合索引(d,a,b,c)<br>工作原理: #如果是你找的话，你会怎么找，是不是从左到右一个一个的比较啊，首先你不能确定a这个字段是不是有索引，即便是有索引，也不一定能确保命中索引了（所谓命中索引，就是应用上了索引），mysql不会这么笨的，看下面mysql是怎么找的： 索引的本质原理就是先不断的把查找范围缩小下来，然后再进行处理，对于连续多个and：mysql会按照联合索引，从左到右的顺序找一个区分度高的索引字段(这样便可以快速锁定很小的范围)，加速查询，即按照d—&gt;a-&gt;b-&gt;c的顺序 </p>
<p>#3、or的工作原理 条件： a = 10 or b = ‘xxx’ or c &gt; 3 or d =4 索引： 制作联合索引(d,a,b,c) 工作原理: 只要一个匹配成功就行，所以对于连续多个or：mysql会按照条件的顺序，从左到右依次判断，即a-&gt;b-&gt;c-&gt;d</p>
</blockquote>
</li>
<li><p>最左前缀匹配原则，非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
</li>
</ul>
<p><strong>其他情况</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- 使用函数</span><br><span class="line">   select * <span class="keyword">from</span> tb1 where reverse(email) = <span class="string">&#x27;egon&#x27;</span>;</span><br><span class="line">       </span><br><span class="line">- 类型不一致</span><br><span class="line">   如果列是字符串类型，传入条件是必须用引号引起来，不然...</span><br><span class="line">   select * <span class="keyword">from</span> tb1 where email = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#排序条件为索引，则select字段必须也是索引字段，否则无法命中</span></span><br><span class="line">- order by</span><br><span class="line">   select name <span class="keyword">from</span> s1 order by email desc;</span><br><span class="line">   当根据索引排序时候，select查询的字段如果不是索引，则速度仍然很慢</span><br><span class="line">   select email <span class="keyword">from</span> s1 order by email desc;</span><br><span class="line">   特别的：如果对主键排序，则还是速度很快：</span><br><span class="line">     select * <span class="keyword">from</span> tb1 order by nid desc;</span><br><span class="line"></span><br><span class="line">- 组合索引最左前缀</span><br><span class="line">   如果组合索引为：(name,email)</span><br><span class="line">   name <span class="keyword">and</span> email    -- 命中索引</span><br><span class="line">   name         -- 命中索引</span><br><span class="line">   email        -- 未命中索引</span><br><span class="line"></span><br><span class="line">- count(<span class="number">1</span>)或count(列)代替count(*)在mysql中没有差别了</span><br><span class="line"></span><br><span class="line">- create index xxxx on tb(title(<span class="number">19</span>)) <span class="comment">#text类型，必须制定长度</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<blockquote>
<p>避免使用select <em>-<br>count(1)或count(列) 代替 count(</em>)<br>创建表时尽量时 char 代替 varchar<br> 表的字段顺序固定长度的字段优先<br> 组合索引代替多个单列索引（经常使用多个条件查询时）<br> 尽量使用短索引<br> 使用连接（JOIN）来代替子查询(Sub-Queries)<br> 连表时注意条件类型需一致<br> 索引散列值（重复少）不适合建索引，例：性别不适合</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
</search>

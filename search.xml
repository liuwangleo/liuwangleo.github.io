<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文让你彻底弄清楚python中装饰器</title>
      <link href="2021/03/07/%E4%B8%80%E6%96%87%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E5%BC%84%E6%B8%85%E6%A5%9Apython%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>2021/03/07/%E4%B8%80%E6%96%87%E8%AE%A9%E4%BD%A0%E5%BD%BB%E5%BA%95%E5%BC%84%E6%B8%85%E6%A5%9Apython%E4%B8%AD%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>面试官：你了解装饰器吗？<br>XXX：了解<br>面试官：那你说说吧<br>XXX：装饰器是…<br>面试官：你先写一个简单的装饰器，再写一个带参的装饰器<br>XXX：xxx。。。<br>面试官：你知道装饰器有哪些应用场景吗<br>XXX：xxx。。。(思考)</p></blockquote><p>​大家是否在面试过程中，经常会遇到上面的问题？本文就让我们一起学习python中装饰器。</p><p><code>装饰器(decorator)</code>可以说是Python的一个神器，它可以在不改变一个函数代码和调用方式的情况下给函数添加新的功能。Python的装饰器同时也是Python学习从入门到精通过程中必需要熟练掌握的知识。今天尝试用浅显的语言解释下Python装饰器的工作原理及如何编写自己的装饰器吧。</p><hr><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>我们先来了解一下它有那些<code>应用场景</code></p><ul><li>附加功能</li><li>数据的清理或添加:<ul><li>函数参数类型验证 @require_ints 类似请求前拦截</li><li>数据格式转换 将函数返回字典改为 JSON/YAML 类似响应后篡改</li><li>为函数提供额外的数据 mock.patch</li></ul></li><li>函数注册<ul><li>在任务中心注册一个任务</li><li>注册一个带信号处理器的函数</li></ul></li></ul><p>你可能还是不理解装饰器是啥？没有关系，下面我们详细的解析一下到底如何去实现装饰器。</p><h1 id="最简单的装饰器"><a href="#最简单的装饰器" class="headerlink" title="最简单的装饰器"></a>最简单的装饰器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&#x27;用时:&#123;&#125;秒&#x27;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@getTime</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;Func1 is running.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    func1()</span><br></pre></td></tr></table></figure><p>上面的代码，<code>func1</code>函数被<code>getTime</code>函数装饰，这个装饰器实现的功能是<code>统计func1函数执行的时间</code>，这其实就是一个最简单的装饰器。<br>如何你还是不太理解，没有关系，我们换种写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTime</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end = time.time()</span><br><span class="line">        print(<span class="string">&#x27;用时:&#123;&#125;秒&#x27;</span>.<span class="built_in">format</span>(end-start))</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;Func1 is running.&quot;</span>)</span><br><span class="line">res = getTime(func1)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>这种写法是不是清晰很多。如果你还是不太理解，也没有关系，接下来我们就看看装饰器的本质。</p><h1 id="本质上的装饰器"><a href="#本质上的装饰器" class="headerlink" title="本质上的装饰器"></a>本质上的装饰器</h1><p>Python的装饰器本质上是一个<code>嵌套函数</code>，它接受被装饰的函数(func)作为参数，并返回一个包装过的函数。这样我们可以在不改变被装饰函数的代码的情况下给被装饰函数或程序添加新的功能。</p><p>Python的装饰器广泛应用于<code>引入日志</code>，<code>执行函数前预备处理</code>，<code>执行函数后清理功能</code>，<code>权限校验</code>(如django中的@login_required和@permission_required装饰器)，<code>缓存</code>，<code>事务处理</code>、<code>性能测试</code>(比如统计一段程序的运行时间)和<code>插入日志</code>等应用场景。有了装饰器，我们就可以抽离出大量与函数功能本身无关的代码，增加一个函数的重用性。</p><p>试想你写了很多程序，一直运行也没啥问题。有一天老板突然让你统计每个程序都运行了多长时间并比较下运行效率。此时如果你去手动修改每个程序的代码一定会让你抓狂，而且还破坏了那些程序的重用性。聪明的程序员是绝不能干这种蠢事的。此时你可以编写一个<code>@time_it</code>的装饰器。如果你想打印出某个函数或程序运行时间，只需在函数前面@一下，是不是很帅?</p><p>由于Python装饰器的工作原理主要依赖于<code>嵌套函数</code>和<code>闭包</code>，所以我们必须先对嵌套函数和闭包有深入的了解。嵌套函数和闭包几乎是Python工作面试必考题哦。闭包相关的讲解请点击: <a href="https://liuwangleo.github.io/2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/">python之作用域和闭包详解</a></p><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><p>如果在一个函数的内部还定义了另一个函数(注意: 是定义，不是引用!），这个函数就叫<code>嵌套函数</code>。外部的我们叫它<code>外函数</code>，内部的我们叫他<code>内函数</code>。</p><p>我们先来看一个最简单的嵌套函数的例子。我们在<code>outer函数</code>里又定义了一<code>个inner函数</code>，并调用了它。你注意到了吗? 内函数在自己作用域内查找局部变量失败后，会进一步向上一层作用域里查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        y = x + <span class="number">1</span></span><br><span class="line">        print(y)</span><br><span class="line">    inner()</span><br><span class="line"></span><br><span class="line">outer() <span class="comment">#输出结果 2</span></span><br></pre></td></tr></table></figure><p>如果我们在外函数里不直接调用内函数，而是通过return inner返回一个内函数的引用 这时会发生什么呢? 你将会得到一个内函数对象，而不是运行结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        y = x + <span class="number">1</span></span><br><span class="line">        print(y)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">outer() <span class="comment"># 输出&lt;function outer.&lt;locals&gt;.inner at 0x039248E8&gt;</span></span><br><span class="line">f1 = outer()</span><br><span class="line">f1() <span class="comment"># 输出2</span></span><br></pre></td></tr></table></figure><p>上述这个案例比较简单，因为outer和inner函数都是没有参数的。我们现在对上述代码做点改动，加入参数。你可以看到外函数的参数或变量可以很容易传递到内函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">x</span>):</span></span><br><span class="line">    a = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">y</span>):</span></span><br><span class="line">        b = y</span><br><span class="line">        print(a+b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">f1 = outer(<span class="number">1</span>) <span class="comment"># 返回inner函数对象</span></span><br><span class="line">f1(<span class="number">10</span>) <span class="comment"># 相当于inner(10)。输出11</span></span><br></pre></td></tr></table></figure><p>如果上例中外函数的<code>变量x</code>换成被<code>装饰函数对象(func)</code>，内函数的<code>变量y</code>换成<code>被装饰函数的参数</code>，我们就可以得到一个通用的装饰器啦。你注意到了吗? 我们在没对func本身做任何修改的情况下，添加了其它功能, 从而实现了对函数的装饰。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        add_other_actions()</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><a href="https://liuwangleo.github.io/2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/">python之作用域和闭包详解</a></p><h1 id="面试中的装饰器"><a href="#面试中的装饰器" class="headerlink" title="面试中的装饰器"></a>面试中的装饰器</h1><h2 id="基本的装饰器"><a href="#基本的装饰器" class="headerlink" title="基本的装饰器"></a>基本的装饰器</h2><p>面试官往往会给你提一些简单的需求，如返回被装饰函数执行时间，函数的名称等，这时候要学会灵活的转变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warpper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;&#123;0&#125; is running&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hint</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;say hello!&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>调用  hello()<br>执行结果：hello is running / say hello!</p></blockquote><p>值得一提的是被装饰器装饰过的函数看上去名字没变，其实已经变了。当你运行<code>print(hello.__name__)</code>后，你会发现它的名字已经悄悄变成了<code>warpper</code>，这显然不是我们想要的。这一点也不奇怪，因为外函数返回的是由<code>warpper函数</code>和其<code>外部引用变量</code>组成的闭包。</p><p><img src="https://img-blog.csdnimg.cn/20201211095412663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片描述"></p><p>为了解决这个问题保证装饰过的函数<code>__name__</code>属性不变，我们可以使用<code>functools</code>模块里的<code>wraps</code>方法，先对<code>func</code>变量进行<code>wraps</code>。下面这段代码可以作为编写一个通用装饰器的示范代码，注意收藏哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; is running&#x27;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hint</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="带参的装饰器"><a href="#带参的装饰器" class="headerlink" title="带参的装饰器"></a>带参的装饰器</h2><p>前面几个装饰器一般是<code>内外两层嵌套函数</code>。如果我们需要编写的装饰器本身是带参数的，我们需要编写三层的嵌套函数，其中最外一层用来传递装饰器的参数。现在我们要对@hint装饰器做点改进，使其能通过@hint(coder=’liuwangleo’)传递参数。该装饰器在函数运行前给出提示的时候还显示函数编写人员的名字。完整代码如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">coder</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            print(<span class="string">&#x27;&#123;&#125; is running&#x27;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">            print(<span class="string">&#x27;Coder: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(coder))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@hint(<span class="params">coder=<span class="string">&quot;liuwangleo&quot;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h2><p>先来一段代码，自行理解一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d1</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">       print(<span class="number">1</span>)</span><br><span class="line">       f()</span><br><span class="line">       print(<span class="string">&quot;我是外边的装饰器&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d2</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="number">2</span>)</span><br><span class="line">        print(f.__name__)</span><br><span class="line">        f()</span><br><span class="line">        print(<span class="string">&quot;我是里边的装饰器&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;哈哈哈&#x27;</span>)</span><br><span class="line">func()</span><br><span class="line"><span class="comment"># 执行结果是啥呢？</span></span><br></pre></td></tr></table></figure><p>不知道你能否理解，如果不明白没有关系，前面我们介绍过装饰器就是嵌套函数，不妨还是换种写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d1</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="number">2</span>)</span><br><span class="line">        f()</span><br><span class="line">        print(<span class="string">&quot;我是外边的装饰器&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d2</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line">        print(f.__name__)</span><br><span class="line">        f()</span><br><span class="line">        print(<span class="string">&quot;我是里边的装饰器&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;哈哈哈&#x27;</span>)</span><br><span class="line">res = d1(d2(func))</span><br></pre></td></tr></table></figure><p>这样是不是就容易理解了，执行结果呢？来了来了。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">func</span><br><span class="line">哈哈哈</span><br><span class="line">我是里边的装饰器</span><br><span class="line">我是外边的装饰器</span><br></pre></td></tr></table></figure><p>如果上面代码没看够，那就再来一段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>(<span class="params">funE_decorated_by_C</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">funE_decorated_by_C</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">redecorated_E</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">        print(<span class="string">&quot;开始执行&quot;</span>, end=<span class="string">&quot;——&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> funE_decorated_by_C(<span class="built_in">str</span>) + <span class="string">&#x27; &gt; redecorated by A&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> redecorated_E</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">C</span>(<span class="params">funE</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">funE</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated_E</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> funE(<span class="built_in">str</span>) + <span class="string">&#x27; &gt; decorated by C&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> decorated_E</span><br><span class="line"><span class="meta">@A</span></span><br><span class="line"><span class="meta">@C</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">E</span>(<span class="params"><span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line">print(E(<span class="string">&#x27;A string is &#x27;</span>))</span><br><span class="line">print(E.__name__)</span><br></pre></td></tr></table></figure><p><strong>接下来不要眨眼，让我们详细的看一下这种多个装饰器的执行过程</strong></p><hr><p><code>开始执行——&gt; A string is &gt; decorated by C &gt; redecorated by A</code></p><p>难理解的地方在C和A在装饰过程中执行的调用关系</p><ul><li><p>可以看到，<code>先调用那个装饰器，那个装饰器就先运行</code><br>  print(“开始执行”, end=”——&gt;”)</p></li><li><p>继续执行 A装饰的是<code>C(A)</code> 即调用 <code>funE_decorated_by_C</code><br>  调用<code> funE_decorated_by_C</code> 执行C</p></li><li><p>C执行 调用E函数 返回的结果<code>&quot; A string is &gt; decorated by C &quot;</code>  作为A中 <code>funE_decorated_by_C</code> 的<code>参数</code></p></li><li><p>最终在A中调用E 返回 A</p></li></ul><hr><p>最后在附上一份案例代码，供参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_b</span>(<span class="params">fun</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_b</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;This is inner_b&#x27;</span>)</span><br><span class="line">        print(<span class="string">&quot;*****&quot;</span>)</span><br><span class="line">        <span class="comment"># print(fun(*args, **kwargs))</span></span><br><span class="line">        <span class="keyword">return</span> fun(*args, **kwargs) + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_a</span>(<span class="params">fun</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_a</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;This is inner_a&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> fun(*args, **kwargs) + <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_b</span></span><br><span class="line"><span class="meta">@decorator_a</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;This is f&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(f(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h1 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h1><p><a href="https://www.cnblogs.com/Lin-Yi/p/7305364.html">https://www.cnblogs.com/Lin-Yi/p/7305364.html</a><br><a href="http://python.jobbole.com/81683/">http://python.jobbole.com/81683/</a><br><a href="http://lib.csdn.net/article/python/62942">http://lib.csdn.net/article/python/62942</a><br><a href="http://lib.csdn.net/article/python/64769">http://lib.csdn.net/article/python/64769</a><br><a href="http://www.cnblogs.com/cicaday/p/python-decorator.html">http://www.cnblogs.com/cicaday/p/python-decorator.html</a></p><p>最新推荐：<br>    <a href="https://mp.weixin.qq.com/s/XTHZ-K1yDNPIoejNFvk6rw">恶补了 Python 装饰器的六种写法，你随便问~</a><br>    <a href="https://blog.csdn.net/LaoYuanPython/article/details/111303395">各种各样的装饰器实现详解</a></p>]]></content>
      
      
      <categories>
          
          <category> python、 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> 装饰器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/03/06/hello-world/"/>
      <url>2021/03/06/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python之作用域与闭包详解</title>
      <link href="2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/03/06/python%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用域介绍"><a href="#作用域介绍" class="headerlink" title="作用域介绍"></a>作用域介绍</h1><p>作用域，也叫名称空间。</p><h2 id="几个相关的概念"><a href="#几个相关的概念" class="headerlink" title="几个相关的概念"></a>几个相关的概念</h2><ul><li>全局名称空间：创建的存储“变量名与值的关系”的空间叫做全局名称空间</li><li>局部名称空间：在函数的运行中开辟的临时的空间叫做局部名称空间</li><li>内置名称空间：内置名称空间中存放了python解释器为我们提供的名字：input,print,str,list,tuple…它们都是我们熟悉的，拿过来就可以用的方法。</li></ul><h2 id="python的作用域"><a href="#python的作用域" class="headerlink" title="python的作用域"></a>python的作用域</h2><ul><li>L：local，局部作用域，即函数中定义的变量；</li><li>E：enclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域，但不是全局的（闭包常见）；</li><li>G：globa，全局变量，就是模块级别定义的变量；</li><li>B：built-in，系统固定模块里面的变量，比如int, bytearray等。</li></ul><p><code>加载变量的优先顺序是由下至上</code><br><code>搜索变量的优先顺序是由上至下，LEGB法则</code></p><h1 id="作用域产生"><a href="#作用域产生" class="headerlink" title="作用域产生"></a>作用域产生</h1><p>在Python中，只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如if、try、for等）是不会引入新的作用域的，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">2</span>&gt;<span class="number">1</span>:</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">print(x)  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>这个是没有问题的，if并没有引入一个新的作用域，x仍处在当前作用域中，后面代码可以使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">print(x) <span class="comment"># NameError: name &#x27;x2&#x27; is not defined</span></span><br></pre></td></tr></table></figure><h1 id="案例和几个关键字"><a href="#案例和几个关键字" class="headerlink" title="案例和几个关键字"></a>案例和几个关键字</h1><h2 id="变量的声明和使用"><a href="#变量的声明和使用" class="headerlink" title="变量的声明和使用"></a>变量的声明和使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line">    x=<span class="number">1</span></span><br><span class="line">f2()</span><br><span class="line"><span class="comment"># local variable &#x27;x&#x27; referenced before assignment</span></span><br></pre></td></tr></table></figure><p>上面的代码执行是会报错的，我们都知道变量是先声明，再引用的，错误的原因在于 print(x)，解释器会在局部作用域找，会找到x=1(函数已经加载到内存),但x使用在声明前了,所以报错；如何证明找到了x=1呢?简单:注释掉x=2,x=1,报错为:<code>name &#39;x&#39; is not defined</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    x+=<span class="number">1</span> <span class="comment">#local variable &#x27;x&#x27; referenced before assignment.  x 使用之前已经被声明了</span></span><br><span class="line"><span class="comment">#x+=1：x = x + 1；x 已经被声明了，x=2，这里等于 2 = 2 + 1，发生报错</span></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><h2 id="global关键字"><a href="#global关键字" class="headerlink" title="global关键字"></a>global关键字</h2><p>针对上边代码的报错，我们知道在局部作用域里是不能操作全局变量的，我们先看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">a = <span class="number">200</span></span><br><span class="line">print(a)</span><br><span class="line">f()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>如果要是想修改这个全局变量a的值，在python中有关键字可以实现这个需求—global</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># global关键字可以在局部中修改全局的变量</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)</span><br><span class="line">f()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 200</span></span><br></pre></td></tr></table></figure><h2 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nonlocal关键字可以修改嵌套的父级函数的局部变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    count = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count = <span class="number">20</span></span><br><span class="line">        print(count)</span><br><span class="line">    inner()</span><br><span class="line">    print(count)</span><br><span class="line">outer()</span><br><span class="line"><span class="comment"># 20</span></span><br><span class="line"><span class="comment"># 20</span></span><br></pre></td></tr></table></figure><p>这段代码是不是看着有点懵比呢。这是因为这个函数使用到了闭包，<strong>inner</strong>函数中使用<strong>nonlocal **修改了count的值，</strong>nonlocal关键字可以修改嵌套的父级函数的局部变量的值<strong>，下面我们了解一下</strong>闭包**</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="特别简单的介绍"><a href="#特别简单的介绍" class="headerlink" title="特别简单的介绍"></a>特别简单的介绍</h2><p> 还是先来段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span>  </span><br><span class="line">    x = <span class="number">1</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span>  </span><br><span class="line">        print(x) <span class="comment"># 1  </span></span><br><span class="line">    <span class="keyword">return</span> inner  </span><br><span class="line">foo = outer()  </span><br><span class="line">print(foo)</span><br><span class="line"><span class="comment"># &lt;function outer.&lt;locals&gt;.inner at 0x000001EDE42878C8&gt; </span></span><br><span class="line">foo()  </span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p><strong>其实这就是闭包</strong></p><p>闭包的三要素：</p><ul><li>定义两个函数内部函数与外部函数  </li><li>在外部函数中存在一个自由变量，内部函数使用 </li><li>外部函数的返回值调用内部函数</li></ul><blockquote><p>在你面试的时候回答闭包问题，完全可以直接附上代码，讲出三要素</p></blockquote><h2 id="闭包的陷阱"><a href="#闭包的陷阱" class="headerlink" title="闭包的陷阱"></a>闭包的陷阱</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">*args</span>):</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">            <span class="keyword">return</span> i * i</span><br><span class="line">        fs.append(func)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">fs1, fs2, fs3 = my_func()</span><br><span class="line">print(fs1())</span><br><span class="line">print(fs2())</span><br><span class="line">print(fs3())</span><br><span class="line"><span class="comment"># 全部返回值为 4</span></span><br><span class="line"><span class="comment"># 返回闭包中不要引用任何循环变量，或者后续会发生变化的变量。</span></span><br><span class="line"><span class="comment"># 这条规则本质上是在返回闭包前，闭包中引用的父函数中定义变量的值可能会发生不是我们期望的变化。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">*args</span>):</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        func = <span class="keyword">lambda</span> _i = i : _i * _i</span><br><span class="line">        fs.append(func)</span><br><span class="line"><span class="keyword">return</span> fs</span><br><span class="line"><span class="comment"># 这个函数返回什么呢？思考一下，可以留言回复</span></span><br></pre></td></tr></table></figure><p>其实就这些东西，一次性弄清楚之后，再遇到相关的问题就不会概念不清，思路混乱。讲到闭包其实<strong>装饰器</strong>也不得不说，装饰器基本面试或者工作用的比较多，之后会专门更一篇相关的博文。<br><a href="https://blog.csdn.net/qq_36581961/article/details/111028518"><strong>在这里：专题九:如何应对面试官的拷问—你了解python的装饰器吗？</strong></a></p><p><strong>谢谢观看，点赞关注不迷路，我很菜还不爱说！</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> 作用域 </tag>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的面试题总结</title>
      <link href="2021/03/05/%E6%A0%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>2021/03/05/%E6%A0%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树的几个概念"><a href="#树的几个概念" class="headerlink" title="树的几个概念"></a>树的几个概念</h1><p>由一个或一个以上的节点组成，存在一个特殊的节点，成为树根。其中的每一个子集合本身也是一种树形结构，即此根节点的子树。</p><p>几个关于树的专有名词</p><ul><li>度数：每个节点所有子树的个数</li><li>层数：树的层数</li><li>高度：树的最大层数</li><li>树叶或终端节点：度数为零的节点就是树叶。</li><li>父节点：每一个节点都有连接的上一层节点。</li><li>子节点：每一个节点都有连接的下一层节点。</li><li>兄弟节点：有共同父节点的节点。</li><li>非终端节点：树叶以内的节点。</li><li>同代：在同一棵具有相同层数的节点。</li></ul><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>由有限节点所组成的集合，此结合可以为空集合，或由一个树根及其左右两个子树组成。<br><strong>特点</strong></p><ul><li>可以是空集合 但若不是空集合 则节点上一定要有一个键值</li><li>每一个树根的值需大于左子树的值</li><li>每一个树根的值需小于右子树的值</li><li>左右子树也是二叉查找树</li><li>树的每一个节点的值都不相同</li></ul><p><strong>二叉树与树的区别</strong></p><ul><li>树不可以为空集合 二叉树可以</li><li>树的度数为d&gt;=0 但二叉树的节点度数为0&lt;=0&lt;=2</li><li>树的子树没有次序关系 二叉树则有</li></ul><blockquote><p>高度为k的二叉树的总结点数为 2<strong>k-1<br>在二叉树中，层数为i的节点数最多为 2</strong>(i-1)</p></blockquote><h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组的方式存储</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeCreateByArray</span>(<span class="params">btree, data, length</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> btree[level] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> data[i] &gt; btree[level]:  <span class="comment"># 如果数组内的值大于树根 就往右子树比较</span></span><br><span class="line">                level = level * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                level = level * <span class="number">2</span></span><br><span class="line">        btree[level] = data[i]</span><br><span class="line">    <span class="keyword">return</span> btree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表的存储方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tree</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = <span class="number">0</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">treeCreateByLinkList</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    newnode = tree()</span><br><span class="line">    newnode.data = val</span><br><span class="line">    newnode.left = <span class="literal">None</span></span><br><span class="line">    newnode.right = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">        root = newnode</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current != <span class="literal">None</span>:</span><br><span class="line">            backup = current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current = current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt; val:</span><br><span class="line">            backup.left = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right = newnode</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">二叉树查找：</span></span><br><span class="line"><span class="string">def search(ptr,val):</span></span><br><span class="line"><span class="string">    while True:</span></span><br><span class="line"><span class="string">        if ptr is None:</span></span><br><span class="line"><span class="string">            return None</span></span><br><span class="line"><span class="string">        if ptr.data == val:</span></span><br><span class="line"><span class="string">            return ptr</span></span><br><span class="line"><span class="string">        elif ptr.data &gt;val:</span></span><br><span class="line"><span class="string">            ptr = ptr.left</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            ptr = ptr.right</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = <span class="number">0</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建一个二叉树</span></span><br><span class="line"><span class="string">    :param root:</span></span><br><span class="line"><span class="string">    :param val:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    newnode = Tree()</span><br><span class="line">    newnode.data = val</span><br><span class="line">    newnode.left = <span class="literal">None</span></span><br><span class="line">    newnode.right = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        root = newnode</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            backup = current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current = current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt; val:</span><br><span class="line">            backup.left = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right = newnode</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">root, val</span>):</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.data == val:</span><br><span class="line">            print(<span class="string">&quot;查找了&#123;0&#125;次&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> root.data &gt; val:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.right</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        inorder(root.left)</span><br><span class="line">        print(<span class="string">&quot;[%2d]&quot;</span> % root.data, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        inorder(root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br><span class="line">    root = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">11</span>):</span><br><span class="line">        root = createTree(root, data[i])</span><br><span class="line">    target = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入查找的数值&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> search(root, target) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">&quot;找到了&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;NO NO ...没找到&quot;</span>)</span><br><span class="line">        print(<span class="string">&quot;准备插入&quot;</span>)</span><br><span class="line">        root = createTree(root, target)</span><br><span class="line">        inorder(root)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">存在三种情况：</span></span><br><span class="line"><span class="string">1.删除的节点为树叶，只要将其相连的父节点指向None</span></span><br><span class="line"><span class="string">2.删除的节点只有一棵子树，</span></span><br><span class="line"><span class="string">3.删除的节点有两棵子树</span></span><br><span class="line"><span class="string">    找出中序立即先行者 即将欲删除节点的左子树中最大者往上提 该节点的左子树往右找 直到右指针指向None</span></span><br><span class="line"><span class="string">    找出中序立即后继者 即将欲删除节点的右子树中最小者往上提 该节点的右子树往左找 直到左指针指向None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h1><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="二叉树的三种遍历方式"><a href="#二叉树的三种遍历方式" class="headerlink" title="二叉树的三种遍历方式"></a>二叉树的三种遍历方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.res = [[], [], []]</span><br><span class="line">        self.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.res[<span class="number">0</span>].append(root.val)</span><br><span class="line">        self.dfs(root.left)</span><br><span class="line">        self.res[<span class="number">1</span>].append(root.val)</span><br><span class="line">        self.dfs(root.right)</span><br><span class="line">        self.res[<span class="number">2</span>].append(root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote><p>题目<br>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。<br>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，<br>    3<br>   / \ <br>  9   20<br>        /  \<br>        15   7</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.val = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 方法一 递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    使用递归的方式</span></span><br><span class="line"><span class="string">    :param root:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line"><span class="comment"># 方法二 广度优先搜索</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这里，我们需要添加一个辅助队列。我们将当前层的所有节点都存入这个辅助队列中。</span></span><br><span class="line"><span class="string">在这里需要注意一点，当我们准备搜索下一层时，这里需要将队列中当前层的所有节点都进行出队，然后让这些节点往下层搜索。</span></span><br><span class="line"><span class="string">那么，如果当前层的所有节点都出列，队列还非空，那么说明下一层还有节点。循环直至队列为空，</span></span><br><span class="line"><span class="string">定义变量 depth，每层搜索的时候维护更新该值，那么最终，depth 就是我们要求的二叉树最大深度。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    queue = deque()</span><br><span class="line">    depth = <span class="number">0</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        depth += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> depth</span><br><span class="line"></span><br><span class="line">maxDepth2([<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">15</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure><h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    levels = []</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="comment"># 定义队列</span></span><br><span class="line">    queue = deque()</span><br><span class="line">    <span class="comment"># 最终的返回结果</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 先将根节点入队</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        <span class="comment"># 记录当前队列的长度</span></span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="comment"># 临时列表存储每一层的节点</span></span><br><span class="line">        cur_level = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 出队</span></span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="comment"># 将当前值存储</span></span><br><span class="line">            cur_level.append(node.val)</span><br><span class="line">            <span class="comment"># 当前值的左右节点非空时 入队</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line"></span><br><span class="line">        result.append(cur_level)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="有序数组转化为二叉树"><a href="#有序数组转化为二叉树" class="headerlink" title="有序数组转化为二叉树"></a>有序数组转化为二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</span></span><br><span class="line"><span class="string">  一.若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span></span><br><span class="line"><span class="string">  二.若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span></span><br><span class="line"><span class="string">  三.它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    length = <span class="built_in">len</span>(nums)</span><br><span class="line">    mid = length // <span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[mid])</span><br><span class="line">    root.left = sortedArrayToBST(nums[:mid])</span><br><span class="line">    root.right = sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">print(sortedArrayToBST([-<span class="number">10</span>, -<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>]))</span><br></pre></td></tr></table></figure><h2 id="判断是否为对称二叉树"><a href="#判断是否为对称二叉树" class="headerlink" title="判断是否为对称二叉树"></a>判断是否为对称二叉树</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">给定一个二叉树，检查它是否是镜像对称的。</span></span><br><span class="line"><span class="string"># 递归大法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> auxiliary(root.left, root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auxiliary</span>(<span class="params">leftNode, rightNode</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> leftNode <span class="keyword">and</span> rightNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> leftNode <span class="keyword">and</span> <span class="keyword">not</span> rightNode:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> leftNode.val != rightNode.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> auxiliary(leftNode.left, rightNode.right) <span class="keyword">and</span> auxiliary(leftNode.right, rightNode.left)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树结构 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> leetcode </tag>
            
            <tag> 面试题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之迭代器、生成器、推导式</title>
      <link href="2021/03/04/python%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E6%8E%A8%E5%AF%BC%E5%BC%8F/"/>
      <url>2021/03/04/python%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8%E3%80%81%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>python中的基础数据类型都可以进行循环遍历，通常这种对象称为<code>可迭代对象</code>。下面我们回顾一下常用的可迭代对象，<code>set list tuple dict set</code>。那为什么我们称他们为可迭代对象呢?因为他们都遵循了可迭代协议,那什么又是可迭代协议呢.首先我们先看一段代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果:</span></span><br><span class="line"><span class="comment">#a b c</span></span><br><span class="line"><span class="comment">#错误的代码:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">123</span>:</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File &quot;D:/python_object/二分法.py&quot;, line 62, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    for i in 123:</span></span><br><span class="line"><span class="comment">#TypeError: &#x27;int&#x27; object is not iterable</span></span><br></pre></td></tr></table></figure><p><strong>注意看报错信息,报错信息中有这样一句话: <code>‘int’ object is not iterable </code>翻译过来就是整数类型对象是不可迭代的.</strong><br><code>iterable</code>表示可迭代的。那么如何进行验证你的数据类型是否符合<code>可迭代协议</code>.我们可以通过<code>dir</code>函数来查看类中定义好的所有方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">dir</span>(a)</span><br><span class="line"><span class="comment"># # 在打印结果中寻找__iter__ 如果存在就表示当前的这个类型是个可迭代对象</span></span><br></pre></td></tr></table></figure><p>这是查看一个对象是否是可迭代对象的第一种方法，我们还可以通过<code>isinstence()</code>函数来查看一个对象是什么类型的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">l_iter = l.__iter__()</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(l,Iterable)) <span class="comment">#True             #查看是不是可迭代对象</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(l,Iterator)) <span class="comment">#False            #查看是不是迭代器</span></span><br><span class="line">print(<span class="built_in">isinstance</span>(l_iter,Iterator)) <span class="comment">#True       </span></span><br><span class="line">print(<span class="built_in">isinstance</span>(l_iter,Iterable)) <span class="comment">#True</span></span><br></pre></td></tr></table></figure><p>这里的<code>__iter__</code>是帮助我们获取到对象的迭代器.我们使用迭代器中的<code>__next__()</code>来获取到一个迭代器的元素,那么我们之前所讲的<code>for循环机制</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;我爱北京天安⻔&quot;</span></span><br><span class="line">c = s.__iter__() <span class="comment"># 获取迭代器</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 使⽤迭代器进⾏迭代. 获取⼀个元素 我</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 爱</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 北</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 京</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 天</span></span><br><span class="line">print(c.__next__()) <span class="comment"># 安</span></span><br><span class="line">print(c.__next__()) <span class="comment"># ⻔</span></span><br><span class="line">print(c.__next__()) <span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>我们使用while循环和迭代器来模拟for循环: 必须要会</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lslst = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">l = lst.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        i = l.__next__()</span><br><span class="line">        print(i)</span><br><span class="line">    <span class="keyword">except</span> StopIteration</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><strong>注意: 迭代器不能反复,只能向下执行,并且是一次性的.获取过了就不能在获取了</strong></p><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p><code>生成器</code>的本质就是<code>迭代器</code>，在python中几种方式来获取生成器</p><ul><li>通过生成器函数</li><li>通过各种推导式实现生成器</li></ul><h2 id="定义生成器"><a href="#定义生成器" class="headerlink" title="定义生成器"></a>定义生成器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>    </span><br><span class="line">    print(<span class="number">11</span>)    </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">22</span></span><br><span class="line">ret = func()</span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment"># 运行结果:&lt;generator object func at 0x000001A575163888&gt;</span></span><br></pre></td></tr></table></figure><p>回想下迭代器是怎么使用的,再想想生成器的本质就是迭代器.我们是不是就可以直接使用迭代器的方式直接使用生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>     </span><br><span class="line">    print(<span class="string">&quot;111&quot;</span>)     </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">222</span></span><br><span class="line">gener = func() </span><br><span class="line"><span class="comment"># 这个时候函数不会执⾏. ⽽是获取到⽣成器</span></span><br><span class="line">ret = gener.__next__()</span><br><span class="line"><span class="comment"># 这个时候函数才会执⾏. yield的作⽤和return⼀样. 也是返回数据</span></span><br><span class="line">print(ret)</span><br><span class="line"><span class="comment">#结果:111222</span></span><br></pre></td></tr></table></figure><p>那么我们可以看到,yield和return的效果是一样的,但是还是有点区别</p><ul><li><code>yield</code>是分段来执行一个函数,<code>yield</code>可以出现多次</li><li>return是直接停止这个函数,return可以出现多次但是只会执行到第一个就结束了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>    </span><br><span class="line">print(<span class="string">&quot;111&quot;</span>)    </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">222</span>    </span><br><span class="line">    print(<span class="string">&quot;333&quot;</span>)   </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">444</span></span><br><span class="line">gener = func()</span><br><span class="line">ret = gener.__next__()</span><br><span class="line">print(ret)</span><br><span class="line">ret2 = gener.__next__()</span><br><span class="line">print(ret2)</span><br><span class="line">ret3 = gener.__next__()</span><br><span class="line"><span class="comment"># 最后⼀个yield执⾏完毕. 再次__next__()程序报错</span></span><br><span class="line">print(ret3)</span><br><span class="line"><span class="comment">#结果:111222333444</span></span><br></pre></td></tr></table></figure><h2 id="生成器作用"><a href="#生成器作用" class="headerlink" title="生成器作用"></a>生成器作用</h2><p><strong>生成器的好处是节省内存</strong></p><h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><p>列表推导式,生成器表达式以及其他推导式,首先我们先看一下这样的代码,给出一个列表,通过循环,想列表中添加1~10:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">li = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):    </span><br><span class="line">    li.append(i)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure><p>我们换成列表推导式是什么样的,来看看:列表推导式的常⽤写法:<br><strong>[结果 for 变量 in 可迭代对象]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">print(ls)</span><br></pre></td></tr></table></figure><p>列表推导式是通过⼀行来构建你要的列表, 列表推导式看起来代码简单. 但是出现错误之后很难排查.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例. 从python1期到python18期写入列表lst:</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&#x27;python%s&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">19</span>)]</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line">lst = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>) <span class="keyword">if</span> i %<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure><h2 id="生成器推导式"><a href="#生成器推导式" class="headerlink" title="生成器推导式"></a>生成器推导式</h2><p>生成器表达式和列表推导式的语法基本上一样的,只是把[]换成()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">print(gen)</span><br><span class="line"><span class="comment"># 结果: &lt;generator object &lt;genexpr&gt; at 0x0000026046CAEBF8&gt;</span></span><br></pre></td></tr></table></figure><p>打印的结果就是一个生成器,我们可以使用for循环来循环这个生成器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gen = (<span class="string">&quot;第%s次&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen:    </span><br><span class="line">print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取1-100内能被3整除的数</span></span><br><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> gen:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="comment"># 100以内能被3整除的数的平⽅</span></span><br><span class="line">gen = (i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> gen:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="comment"># 寻找名字中带有两个e的人的名字</span></span><br><span class="line">names = [[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Billy&#x27;</span>, <span class="string">&#x27;Jefferson&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;Wesley&#x27;</span>, <span class="string">&#x27;Steven&#x27;</span>, <span class="string">&#x27;Joe&#x27;</span>],</span><br><span class="line">         [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Jill&#x27;</span>, <span class="string">&#x27;Ana&#x27;</span>, <span class="string">&#x27;Wendy&#x27;</span>, <span class="string">&#x27;Jennifer&#x27;</span>, <span class="string">&#x27;Sherry&#x27;</span>, <span class="string">&#x27;Eva&#x27;</span>]]</span><br><span class="line"><span class="comment"># 不用推导式和表达式</span></span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> first <span class="keyword">in</span> names:</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> first:</span><br><span class="line">        <span class="keyword">if</span> name.count(<span class="string">&quot;e&quot;</span>) &gt;= <span class="number">2</span>:</span><br><span class="line">            result.append(name)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># 推导式</span></span><br><span class="line">gen = (name <span class="keyword">for</span> first <span class="keyword">in</span> names <span class="keyword">for</span> name <span class="keyword">in</span> first <span class="keyword">if</span> name.count(<span class="string">&#x27;e&#x27;</span>) &gt;= <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> gen:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p><strong>生成器表达式和列表推导式的区别:</strong></p><ul><li>列表推导式比较耗内存,一次性加载.生成器表达式几乎不占用内存.使用的时候才分配和使用内存</li><li>得到的值不一样,列表推导式得到的是一个列表.生成器表达式获取的是一个</li></ul><h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><p>根据名字应该也能猜到,推到出来的是字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lst1 = [<span class="string">&#x27;jay&#x27;</span>,<span class="string">&#x27;jj&#x27;</span>,<span class="string">&#x27;meet&#x27;</span>]</span><br><span class="line">lst2 = [<span class="string">&#x27;周杰伦&#x27;</span>,<span class="string">&#x27;林俊杰&#x27;</span>,<span class="string">&#x27;郭宝元&#x27;</span>]</span><br><span class="line">dic = &#123;lst1[i]:lst2[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst1))&#125;</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure><h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><p>集合推导式可以帮我们直接生成一个集合,集合的特点;无序,不重复 所以集合推导式自带去重功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lst = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,-<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">s = &#123;<span class="built_in">abs</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> lst&#125;</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
            <tag> 推导式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="2021/03/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2021/03/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用排序算法汇总比较"><a href="#常用排序算法汇总比较" class="headerlink" title="常用排序算法汇总比较"></a>常用排序算法汇总比较</h1><table border="1">    <tr>      <th>分类</th>      <th>类型</th>        <th>方法</th>      <th>时间复杂度(平均)</th>      <th>时间复杂度(最坏)</th>      <th>时间复杂度(最好)</th>      <th>空间复杂度</th>      <th>稳定性</th>    </tr >    <tr>        <td rowspan="8" style="text-align:center;vertical-align: middle;">比较类</td>        <td rowspan="2" style="text-align:center;vertical-align: middle;">交换排序</td>        <td>冒泡排序</td>       <td>O(n²)</td>          <td>O(n²)</td>          <td>O(n)</td>          <td>O(1)</td>          <td>稳定</td>    </tr>    <tr>        <td>快速排序</td>        <td>O(nlog2n)</td>          <td>O(n²)</td>          <td>O(nlog2n)</td>          <td>O(nlog2n)</td>          <td>不稳定</td>    </tr>    <tr>        <td rowspan="2" style="text-align:center;vertical-align: middle;">插入排序</td>        <td>简单插入排序</td>          <td>O(n²)</td>          <td>O(n²)</td>          <td>O(n)</td>          <td>O(1)</td>          <td>稳定</td>    </tr>    <tr>        <td>希尔排序</td>        <td>O(n²)</td>          <td>O(n²)</td>          <td>O(n)</td>          <td>O(1)</td>          <td>不稳定</td>    </tr>   <tr>        <td rowspan="2" style="text-align:center;vertical-align: middle;">选择排序</td>        <td>选择排序</td>          <td>O(n²)</td>          <td>O(n²)</td>          <td>O(n²)</td>          <td>O(1)</td>          <td>不稳定</td>    </tr>  <tr>        <td>堆排序</td>        <td>O(nlog2n)</td>          <td>O(nlog2n)</td>          <td>O(nlog2n)</td>          <td>O(1)</td>          <td>不稳定</td>    </tr>  <tr>        <td rowspan="2" style="text-align:center;vertical-align: middle;">归并排序</td>        <td>两路归并排序</td>          <td>O(nlog2n)</td>          <td>O(nlog2n)</td>          <td>O(nlog2n)</td>          <td>O(n)</td>          <td>稳定</td>    </tr>  <tr>        <td>多路归并排序</td>          <td></td>          <td></td>          <td></td>          <td></td>          <td></td>    </tr>  <tr>        <td rowspan="3" style="text-align:center;vertical-align: middle;">非比较类</td>        <td>计数排序</td>         <td rowspan="3" style="text-align:center;vertical-align: middle;"></td>         <td>O(n+k)</td>          <td>O(n+k)</td>          <td>O(n+k)</td>          <td>O(n+k)</td>          <td>稳定</td>    </tr>  <tr>        <td>桶排序</td>         <td>O(n+k)</td>          <td>O(n²)</td>          <td>O(n)</td>          <td>O(n+k)</td>          <td>稳定</td>    </tr>  <tr>        <td>基数排序</td>         <td>O(n*k)</td>          <td>O(n*k)</td>          <td>O(n*k)</td>          <td>O(n+k)</td>          <td>稳定</td>    </tr></table><blockquote><p>给大家推荐一个网站，理解常用排序算法的执行过程 <a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p></blockquote><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><ul><li>比较相邻的元素，如果第一个比第二个大，就交换它们两个</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p><strong>注意:我们知道冒泡排序有一个缺点，就是无论数据是否已排序完成，都固定会执行n(n-1)/2次。可以设计一个程序，使用岗哨的概念，提前中断程序，以此提高程序执行效率</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort1</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        flag = <span class="number">0</span>  <span class="comment"># 判断是否执行了交换操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line">                flag += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><blockquote><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p></blockquote><h2 id="算法理解-1"><a href="#算法理解-1" class="headerlink" title="算法理解"></a>算法理解</h2><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= <span class="number">2</span>:</span><br><span class="line">        mid = data[<span class="built_in">len</span>(data) // <span class="number">2</span>]</span><br><span class="line">        left, right = [], []</span><br><span class="line">        data.remove(mid)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> data:</span><br><span class="line">            <span class="keyword">if</span> num &gt;= mid:</span><br><span class="line">                right.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left.append(num)</span><br><span class="line">        <span class="keyword">return</span> quick_sort(left) + [mid] + quick_sort(right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(quickSort([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">12</span>]))</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 一点小建议 可以在纸上画一下整个执行流程 便于理解  <a href="https://img-blog.csdnimg.cn/20190331172055940.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzI1MDYyMw==,size_16,color_FFFFFF,t_70">参考这里</a>。我总觉的自己实现的代码有点问题，如果有好的建议可以去<a href="https://blog.csdn.net/qq_36581961/article/details/111350029">CSDN-这篇博客</a>留言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一行代码实现</span></span><br><span class="line">quick_sort = <span class="keyword">lambda</span> array: array <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span> <span class="keyword">else</span> quick_sort(</span><br><span class="line">    [item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &lt;= array[<span class="number">0</span>]]) + [array[<span class="number">0</span>]] + quick_sort(</span><br><span class="line">    [item <span class="keyword">for</span> item <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> item &gt; array[<span class="number">0</span>]])</span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><blockquote><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></blockquote><h2 id="算法理解-2"><a href="#算法理解-2" class="headerlink" title="算法理解"></a>算法理解</h2><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertSort</span>(<span class="params">arr</span>):</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(arr)):</span><br><span class="line">current = arr[i]</span><br><span class="line">preIndex = i - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> preIndex &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[preIndex] &gt; current:</span><br><span class="line">arr[preIndex+<span class="number">1</span>] = arr[preIndex]</span><br><span class="line">preIndex -= <span class="number">1</span></span><br><span class="line">arr[preIndex+<span class="number">1</span>] = current</span><br><span class="line"><span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="算法理解-3"><a href="#算法理解-3" class="headerlink" title="算法理解"></a>算法理解</h2><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    jmp = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> jmp != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(jmp, <span class="built_in">len</span>(arr)):</span><br><span class="line">            tmp = arr[i]</span><br><span class="line">            j = i - jmp</span><br><span class="line">            <span class="keyword">while</span> tmp &lt; arr[j] <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                arr[j + jmp] = arr[j]</span><br><span class="line">                j = j - jmp</span><br><span class="line">            arr[jmp + j] = tmp</span><br><span class="line">        print(<span class="string">&quot;第&#123;0&#125;次排序过程&quot;</span>.<span class="built_in">format</span>(k))</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">        jmp = jmp // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">    res = shellSort(arr)</span><br><span class="line">    print(res)</span><br><span class="line">    print(insertSort([<span class="number">2</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><blockquote><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><h2 id="算法理解-4"><a href="#算法理解-4" class="headerlink" title="算法理解"></a>算法理解</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1…n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1…i-1]和R(i…n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R- 交换，使R[1…i]和R[i+1…n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[minIndex]:</span><br><span class="line">                minIndex = j</span><br><span class="line">        temp = arr[i]</span><br><span class="line">        arr[i] = arr[minIndex]</span><br><span class="line">        arr[minIndex] = temp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    arr = [<span class="number">2</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">    res = selectionSort(arr)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法理解-5"><a href="#算法理解-5" class="headerlink" title="算法理解"></a>算法理解</h2><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span>(<span class="params">arr, size</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size // <span class="number">2</span>)[::-<span class="number">1</span>]:</span><br><span class="line">        ad_heap(arr, i, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ad_heap</span>(<span class="params">arr, i, size</span>):</span></span><br><span class="line">    lchild = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">    rchild = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">    maxs = i</span><br><span class="line">    <span class="keyword">if</span> i &lt; size // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> lchild &lt; size <span class="keyword">and</span> arr[lchild] &gt; arr[maxs]:</span><br><span class="line">            maxs = lchild</span><br><span class="line">        <span class="keyword">if</span> rchild &lt; size <span class="keyword">and</span> arr[rchild] &gt; arr[maxs]:</span><br><span class="line">            maxs = rchild</span><br><span class="line">        <span class="keyword">if</span> maxs != i:</span><br><span class="line">            arr[maxs], arr[i] = arr[i], arr[maxs]</span><br><span class="line">            ad_heap(arr, maxs, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapSort</span>(<span class="params">arr, size</span>):</span></span><br><span class="line">    build_heap(arr, size)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, size)[::-<span class="number">1</span>]:</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        ad_heap(arr, <span class="number">0</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">14</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">21</span>, <span class="number">19</span>]</span><br><span class="line">    heapSort(a, <span class="built_in">len</span>(a))</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法理解-6"><a href="#算法理解-6" class="headerlink" title="算法理解"></a>算法理解</h2><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><p><img src="https://img-blog.csdnimg.cn/2020121521433053.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片"></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    lens = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">if</span> lens &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    middle = lens // <span class="number">2</span></span><br><span class="line">    left = arr[: middle]</span><br><span class="line">    right = arr[middle:]</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    c = []</span><br><span class="line">    h, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> h &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[j] &lt; right[h]:</span><br><span class="line">            c.append(left[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c.append(right[h])</span><br><span class="line">            h += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> j == <span class="built_in">len</span>(left):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> right[h:]:</span><br><span class="line">            c.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left[j:]:</span><br><span class="line">            c.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = [<span class="number">14</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">21</span>, <span class="number">19</span>]</span><br><span class="line">    print(mergeSort(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 比较类排序 </tag>
            
            <tag> 非比较类排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之赋值、浅拷贝和深拷贝</title>
      <link href="2021/03/04/python%E4%B9%8B%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>2021/03/04/python%E4%B9%8B%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p><strong>注意：</strong> 结合实际的案例 理解概念</p></blockquote><h1 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h1><p>在python中，变量的赋值实际就是简单的<code>对象引用</code>，在创建一个对象后，将这个对象赋值给另外一个变量时，python并没有拷贝这个对象，只是拷贝这个对象的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义列表alist</span></span><br><span class="line">alist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 赋值于变量blist</span></span><br><span class="line">blist = alist</span><br><span class="line"><span class="comment"># 查看alist与blist的内存地址  </span></span><br><span class="line">print(<span class="string">&#x27;alist id = &#x27;</span>, <span class="built_in">id</span>(alist))</span><br><span class="line">print(<span class="string">&#x27;blist id = &#x27;</span>, <span class="built_in">id</span>(blist))</span><br><span class="line"><span class="comment">#alist和blist的内存地址是一样的</span></span><br><span class="line"><span class="comment"># alist id = 1337323184776</span></span><br><span class="line"><span class="comment"># blist id = 1337323184776</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任何修改alist或blist的值，再分别读取</span></span><br><span class="line">print(<span class="string">&#x27;修改alist的值后&#x27;</span>)</span><br><span class="line">alist.append(<span class="string">&#x27;a_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># [1,2,3,&#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1,2,3,&#x27;a_append&#x27;]</span></span><br><span class="line">print(<span class="string">&#x27;修改blist的值后&#x27;</span>)</span><br><span class="line">blist.append(<span class="string">&#x27;b_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># [1,2,3,&#x27;b_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1,2,3,&#x27;b_append&#x27;]</span></span><br><span class="line"><span class="comment"># 修改任意一个list 两者的都发生变化   alist == blist</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>通过<code>copy</code>模块里面的浅拷贝函数<code>copy()</code>，对原始变量指向的对象进行浅拷贝，然后浅拷贝生成的新对象赋值给新的变量<br>浅拷贝会创建一个对象，对于对象中的元素，浅拷贝就只会使用原始元素的引用（内存地址）</p><p><strong>对内部元素影响</strong></p><ul><li>不可变类型：浅拷贝只是地址指向，不会开辟新空间</li><li>可变的数据类型：浅拷贝会开辟新的空间地址(仅仅是顶层开辟了新的空间，里层的元素地址还是一样的)，进行浅拷贝</li><li>浅拷贝后，改变原始对象中可变类型元素的值，会同时影响拷贝对象，改变原始对象中不可变类型元素的值，只有原始类型受影；操作拷贝对象对原始对象的也是同理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="comment">#定义alist，并拷贝给blist</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">blist = alist.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist 与 blist内存地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist的地址分别为&#x27;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(alist))</span><br><span class="line">print(<span class="built_in">id</span>(blist))</span><br><span class="line"><span class="comment"># alist与blist的地址分别为</span></span><br><span class="line"><span class="comment"># 2056373019592</span></span><br><span class="line"><span class="comment"># 2056373060616</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist与blist内元素的地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist内元素的地址分别为&#x27;</span>)</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> alist])</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> blist])</span><br><span class="line"><span class="comment"># alist与blist内元素的地址分别为</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 2056373019336]</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 2056373019336]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist的内元素的值&#x27;</span>)</span><br><span class="line">alist.append(<span class="string">&#x27;a_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># 修改alist的内元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8]]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist中的列表元素的值&#x27;</span>)</span><br><span class="line">alist[<span class="number">3</span>].append(<span class="string">&#x27;a_second_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment">#修改alist中的列表元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8, &#x27;a_second_append&#x27;], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8, &#x27;a_second_append&#x27;]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>通过<code>copy</code>模块里面的深拷贝函数<code>deepcopy()</code>，对原始变量指向的对象进行深拷贝，然后深拷贝生成的新对象赋值给新的变量.跟浅拷贝类似，深拷贝也会创建一个新的对象</p><blockquote><p>对于对象中的元素，深拷贝都会重新生成一份，而不是简单的使用原始元素的引用（内存地址）<br>经过深拷贝后，原始对象和拷贝对象所有的子元素地址都是独立的了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义alist，并深度拷贝给blist</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">blist = copy.deepcopy(alist)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist 与 blist内存地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist的地址分别为&#x27;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(alist))</span><br><span class="line">print(<span class="built_in">id</span>(blist))</span><br><span class="line"><span class="comment"># alist与blist的地址分别为</span></span><br><span class="line"><span class="comment"># 2612203103176</span></span><br><span class="line"><span class="comment"># 2612203144200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看alist与blist内元素的地址</span></span><br><span class="line">print(<span class="string">&#x27;alist与blist内元素的地址分别为&#x27;</span>)</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> alist])</span><br><span class="line">print([<span class="built_in">id</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> blist])</span><br><span class="line"><span class="comment"># alist与blist内元素的地址分别为</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 1993019826888]</span></span><br><span class="line"><span class="comment"># [140710155244576, 140710155244608, 140710155244640, 1993020930824]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist的内元素的值&#x27;</span>)</span><br><span class="line">alist.append(<span class="string">&#x27;a_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># 修改alist的内元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8]]</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;修改alist中的列表元素的值&#x27;</span>)</span><br><span class="line">alist[<span class="number">3</span>].append(<span class="string">&#x27;a_second_append&#x27;</span>)</span><br><span class="line">print(alist)</span><br><span class="line">print(blist)</span><br><span class="line"><span class="comment"># 修改alist中的列表元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8, &#x27;a_second_append&#x27;], &#x27;a_append&#x27;]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, [6, 7, 8]]</span></span><br></pre></td></tr></table></figure><p><strong>最后附图一张，便于理解：</strong> <a href="https://blog.csdn.net/colourful_sky/article/details/81263998?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.not_use_machine_learn_pai">点击查看图源…</a></p><p><img src="https://img-blog.csdnimg.cn/20201210091158136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTgxOTYx,size_16,color_FFFFFF,t_70" alt="图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> 深浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详谈python中的几个高阶函数</title>
      <link href="2021/03/03/%E8%AF%A6%E8%B0%88python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
      <url>2021/03/03/%E8%AF%A6%E8%B0%88python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>详谈python的sort、sorted、map、filter、reduce 函数</strong></p><h1 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h1><p><code>sort()</code>函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。<code>list.sort(key=None, reverse=False)</code></p><ul><li>key:主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse:排序规则，reverse = True 降序， reverse = False 升序（默认）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>)]</span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>) <span class="comment"># 按照元祖的第二个元素排序（降序）</span></span><br><span class="line">print(l)</span><br><span class="line"><span class="comment"># [(3, 4), (1, 3), (2, 2), (4, 1)]</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h1><ul><li><p>对列表排序,返回的对象不会改变原列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 7]</span></span><br><span class="line"><span class="comment">#可以设定时候排序方式，默认从小到大，设定reverse = False 可以从大到小</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">list</span>,reverse=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># [1, 2, 4, 5, 7]</span></span><br><span class="line"><span class="built_in">sorted</span>(<span class="built_in">list</span>,reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># [7, 5, 4, 2, 1]</span></span><br></pre></td></tr></table></figure></li><li><p>根据自定义规则来排序，使用参数：key</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用key,默认搭配lambda函数使用</span></span><br><span class="line"><span class="built_in">sorted</span>(chars,key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x))</span><br><span class="line"><span class="comment">#[&#x27;a&#x27;, &#x27;is&#x27;, &#x27;boy&#x27;, &#x27;bruce&#x27;, &#x27;handsome&#x27;]</span></span><br><span class="line"><span class="built_in">sorted</span>(chars,key=<span class="keyword">lambda</span> x:<span class="built_in">len</span>(x),reverse= <span class="literal">True</span>)</span><br><span class="line"><span class="comment">#[&#x27;handsome&#x27;, &#x27;bruce&#x27;, &#x27;boy&#x27;, &#x27;is&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>根据自定义规则来排序，对元组构成的列表进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple_list = [(<span class="string">&#x27;A&#x27;</span>, <span class="number">1</span>,<span class="number">5</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>,<span class="number">2</span>), (<span class="string">&#x27;C&#x27;</span>, <span class="number">2</span>,<span class="number">6</span>)]</span><br><span class="line"><span class="comment">#key=lambda x: x[1]中可以任意选定x中可选的位置进行排序</span></span><br><span class="line"><span class="built_in">sorted</span>(tuple_list, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) </span><br><span class="line"><span class="comment">#[(&#x27;A&#x27;, 1, 5), (&#x27;C&#x27;, 2, 6), (&#x27;B&#x27;, 3, 2)]</span></span><br><span class="line"><span class="built_in">sorted</span>(tuple_list, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"><span class="comment">#[(&#x27;A&#x27;, 1, 5), (&#x27;B&#x27;, 3, 2), (&#x27;C&#x27;, 2, 6)]</span></span><br><span class="line"><span class="built_in">sorted</span>(tuple_list, key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>])</span><br><span class="line"><span class="comment">#[(&#x27;B&#x27;, 3, 2), (&#x27;A&#x27;, 1, 5), (&#x27;C&#x27;, 2, 6)]</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h1><p>python的<code>map</code>函数使得函数能直接以list的每个元素作为参数传递到<code>funcname</code>中, 并返回响应的新的<code>list</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sq</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">return</span> x*x <span class="comment">#求x的平方</span></span><br><span class="line"><span class="built_in">map</span>(sq, [<span class="number">1</span>,<span class="number">3</span>, <span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#[1, 9, 25, 49, 81]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br></pre></td></tr></table></figure><h1 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h1><p><code>filter(function or None, iterable)</code>执行过程依次将list中的元素传递到funcname函数中, 根据funcname返回的True或False 保留或丢弃元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_int</span>(<span class="params">x</span>):</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>)):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"> <span class="built_in">filter</span>(is_int, [<span class="string">&quot;Yi&quot;</span>,<span class="number">2</span>, <span class="string">&quot;3&quot;</span>, <span class="number">4</span>]) <span class="comment">#[2, 4]</span></span><br></pre></td></tr></table></figure><h1 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h1><p>与map相比 , reduce类似于一个聚合类的应用方法, 把list中的参数, 依次传递给funcname, 每次funcname的参数都是上个funcname 执行结果和下一个list中的元素, 所以, funcname 的 参数必须是两个. 从执行过程看, 有点像递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#例如: 求range(1, 101)(不包括101)的和,</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c_sum</span>(<span class="params">x, y</span>):</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">reduce(c_sum, <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>)) <span class="comment">#5050</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> 高阶函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python垃圾回收机制</title>
      <link href="2021/03/03/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>2021/03/03/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p>你哈</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python进阶 </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础篇—语法</title>
      <link href="2021/03/03/python%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>2021/03/03/python%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><p>整形就是十进制整数的统称。<a href="https://blog.csdn.net/qq_36581961/article/details/110467300">https://blog.csdn.net/qq_36581961/article/details/110467300</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">99</span></span><br><span class="line">print(<span class="built_in">type</span>(number)) <span class="comment"># 查看类型</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>字符串就是平时用来表示文本信息。<a href="https://blog.csdn.net/qq_36581961/article/details/110517151">https://blog.csdn.net/qq_36581961/article/details/110517151</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;我是字符串-单引号&#x27;</span></span><br><span class="line">s2 = <span class="string">&quot;我是字符串-双引号&quot;</span></span><br><span class="line">s3 = <span class="string">&#x27;&#x27;&#x27;我是用来多行或者换行表示字符串-单引号&#x27;&#x27;&#x27;</span></span><br><span class="line">s4 = <span class="string">&quot;&quot;&quot;我是用来多行或者换行表示字符串-双引号&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断字符串以xx开头 返回布尔值</span></span><br><span class="line">s = <span class="string">&quot;tmd 烦死了&quot;</span></span><br><span class="line">result = s.startwith(<span class="string">&#x27;tmd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串以xx结尾 返回布尔值</span></span><br><span class="line">s = <span class="string">&#x27;生命最将会结束&#x27;</span></span><br><span class="line">result = s.endwith(<span class="string">&#x27;结束&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断字符串是否为十进制数字 返回布尔值</span></span><br><span class="line">s = <span class="string">&#x27;111&#x27;</span></span><br><span class="line">result = s.isdecimal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除空格</span></span><br><span class="line">s = <span class="string">&#x27;  我的是liuwangleo   &#x27;</span></span><br><span class="line">s.strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串大小写转换</span></span><br><span class="line">s = <span class="string">&#x27;Hello World LEO&#x27;</span></span><br><span class="line">su = s.upper()</span><br><span class="line">sl = su.lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内容替换</span></span><br><span class="line">s = <span class="string">&#x27;祝你幸福，你要好好的&#x27;</span></span><br><span class="line">s.replace(<span class="string">&#x27;你&#x27;</span>，<span class="string">&#x27;我&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符出切割</span></span><br><span class="line">s = <span class="string">&#x27;1,2,3,4,5&#x27;</span></span><br><span class="line">s.split(<span class="string">&#x27;,&#x27;</span>)  <span class="comment"># [1,2,3,4,5]</span></span><br><span class="line"><span class="comment"># 注意 加第二参数时 </span></span><br><span class="line">s.split(<span class="string">&#x27;,&#x27;</span>,<span class="number">2</span>)  <span class="comment"># 分割次数 默认为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串拼接</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;-&#x27;</span>.join(l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串</span></span><br><span class="line"><span class="comment"># %s</span></span><br><span class="line"><span class="comment"># format</span></span><br><span class="line">s1 = <span class="string">&quot;我喜欢&#123;0&#125;、&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">s2 = <span class="string">&quot;我喜欢%s、%s&quot;</span> % (<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换</span></span><br><span class="line">s = <span class="built_in">str</span>(<span class="number">1111</span>)</span><br><span class="line"><span class="built_in">type</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取长度</span></span><br><span class="line">s = <span class="string">&#x27;我有多长&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这部分建议去shell里测试一下</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 索引 重要 *</span></span><br><span class="line">s = <span class="string">&#x27;1234,木头人@leo&#x27;</span></span><br><span class="line">s[<span class="number">0</span>]</span><br><span class="line">s[<span class="built_in">len</span>(s)-<span class="number">1</span>]</span><br><span class="line">s[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">s = <span class="string">&#x27;liuwangleo.github.io&#x27;</span></span><br><span class="line">s[<span class="number">0</span>:]</span><br><span class="line">s[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">s[:-<span class="number">1</span>]</span><br><span class="line">s[-<span class="number">2</span>:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长 </span></span><br><span class="line">s = <span class="string">&quot;生活不是电影，生活比电影苦&quot;</span></span><br><span class="line">s[::<span class="number">2</span>]</span><br><span class="line">s[<span class="number">2</span>::<span class="number">2</span>]</span><br><span class="line">s[::-<span class="number">1</span>]  <span class="comment">#倒序</span></span><br><span class="line">s[<span class="number">1</span>:<span class="number">3</span>:-<span class="number">1</span>]  <span class="comment"># 报错</span></span><br><span class="line">s[<span class="number">3</span>:<span class="number">1</span>:-<span class="number">1</span>]  <span class="comment"># &#x27;是不&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>可以把列表当做是一个有序的容器，在里面可以放很多的元素。<a href="https://blog.csdn.net/qq_36581961/article/details/110517411">https://blog.csdn.net/qq_36581961/article/details/110517411</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加 </span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">data.append(<span class="string">&#x27;字符串混入&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="string">&#x27;22&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">data.insert(<span class="number">0</span>,<span class="string">&#x27;0a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展</span></span><br><span class="line">data = [<span class="string">&#x27;嗯&#x27;</span>,<span class="string">&#x27;哦&#x27;</span>]</span><br><span class="line">data.extend([<span class="string">&#x27;啊&#x27;</span>,<span class="string">&#x27;哈&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据值移除</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.remove(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">data.remove(<span class="string">&#x27;q&#x27;</span>) <span class="comment"># 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据索引删除</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.pop()</span><br><span class="line">data.pop(<span class="number">1</span>) <span class="comment"># 删除索引未2的值 倒数第二个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空列表</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转列表</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data.reverse()</span><br></pre></td></tr></table></figure><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取长度</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line"><span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[<span class="number">0</span>]</span><br><span class="line">data[-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改元素</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[-<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">data[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长</span></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;q&#x27;</span>]</span><br><span class="line">data[<span class="number">0</span>::<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>元组也是一个容器，里面可以存放各种数据（和列表相似），但他有一个特殊的特点：元组的儿子元素不允许添加、不允许修改、不允许删除，只能读。<a href="https://blog.csdn.net/qq_36581961/article/details/110621604">https://blog.csdn.net/qq_36581961/article/details/110621604</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>,)</span><br><span class="line">t3 = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">t3 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 面试题</span></span><br><span class="line"><span class="string">1. 比较值 v1 = (1) 和 v2 = 1 和 v3 = (1,) 有什么区别？</span></span><br><span class="line"><span class="string">2. 比较值 v1 = ((1),(2),(3)) 和 v2 = ((1,),(2,),(3,),) 有什么区别？</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">元组和列表十分相似 但由于元组的子元素无法修改的特点，</span></span><br><span class="line"><span class="string">所有在元组都没有修改、删除、添加的操作，只有读操作。</span></span><br><span class="line"><span class="string">所以 这部分参考列表就可以。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>字典也可以当做是个容器，在内部可以存放数据。相比较于元组和列表，字典的元素必须是<code>键值对</code><br><a href="https://blog.csdn.net/qq_36581961/article/details/110621888">https://blog.csdn.net/qq_36581961/article/details/110621888</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>, <span class="string">&quot;name&quot;</span>:<span class="string">&quot;11&quot;</span>,<span class="string">&quot;hobby&quot;</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]&#125;<span class="comment"># 例如： &quot;age&quot;:12 称为一个键值对。</span></span><br><span class="line">d = &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：字典的键有特殊要求，即：必须可哈希 。 目前为止学到的可哈希的类型：int/bool/str/tuple；不可哈希的类型：list/dict</p></blockquote><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>, <span class="string">&quot;name&quot;</span>:<span class="string">&quot;11&quot;</span>,<span class="string">&quot;hobby&quot;</span>:[<span class="string">&#x27;篮球&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有键</span></span><br><span class="line">info.keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有值</span></span><br><span class="line">info.values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键值</span></span><br><span class="line">info.items()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新字典键值对</span></span><br><span class="line">info.update(&#123;<span class="string">&#x27;age&#x27;</span>:<span class="number">13</span>&#125;) <span class="comment">## info中没有的键直接添加；有的键则更新值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除字典的键值对</span></span><br><span class="line">info.pop(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据键获取值</span></span><br><span class="line">info.get(<span class="string">&#x27;name&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>集合与元组和列表相似都用于做容器，在内部可以放一些子元素，但集合有三特殊特点： 子元素不重复 、 子元素必须可哈希、无序.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">99</span>,<span class="number">18</span>&#125;</span><br><span class="line">v2 = &#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;Ee&quot;</span>&#125;</span><br><span class="line">v3 = &#123;<span class="number">1</span>,<span class="literal">True</span>,<span class="string">&quot;world&quot;</span>,(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>)&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">data.add(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素</span></span><br><span class="line">data.discard(<span class="string">&#x27;c&#x27;</span>) <span class="comment">#不存在不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125; </span><br><span class="line">s2 = &#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125; </span><br><span class="line">s3 = s1 &amp; s2   <span class="comment"># 方式一：取两个集合的交集 </span></span><br><span class="line">s4 = s1.intersection(s2)) <span class="comment"># 方式二：取两个集合的交集</span></span><br><span class="line">print(s3,s4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125; </span><br><span class="line">s2 = &#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;&#125; </span><br><span class="line">s3 = s1 | s2               <span class="comment"># 方式一：取两个集合的并集 </span></span><br><span class="line">s4 = s1.union(s2))         <span class="comment"># 方式二：取两个集合的并集 </span></span><br><span class="line">print(s3,s4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集</span></span><br><span class="line">s1 = &#123;<span class="string">&quot;刘能&quot;</span>, <span class="string">&quot;赵四&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125; </span><br><span class="line">s2 = &#123;<span class="string">&quot;刘科⻓&quot;</span>, <span class="string">&quot;冯乡⻓&quot;</span>, <span class="string">&quot;⽪⻓⼭&quot;</span>&#125; </span><br><span class="line">s3 = s1 - s2                       <span class="comment"># 方式一：差集，s1中有且s2中没有的值 </span></span><br><span class="line">s4 = s1.difference(s2)         <span class="comment"># 方式二：差集，s1中有且s2中没有的值 </span></span><br><span class="line">print(s3,s4) </span><br><span class="line">s5 = s2 - s1                     <span class="comment"># 方式一：差集，s2中有且s1中没有的值 </span></span><br><span class="line">s6 = s2.difference(s1)           <span class="comment"># 方式一：差集，s2中有且s1中没有的值 </span></span><br><span class="line">print(s5,s6)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 基础语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟环境详细介绍</title>
      <link href="2021/03/02/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
      <url>2021/03/02/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h1><h2 id="为什么要使用虚拟环境"><a href="#为什么要使用虚拟环境" class="headerlink" title="为什么要使用虚拟环境"></a>为什么要使用虚拟环境</h2><p>到目前位置，我们所有的第三方包安装都是直接通过<strong>pip install</strong>的方式进行安装的，这样安装会将那个包安装到你的系统级的<strong>python</strong>环境中。但是这样有一个问题，就是如果你现在用<strong>Django2.0</strong>写了个网站，然后你的领导跟你说，之前有一个旧项目是用<strong>Django1.0</strong>开发的，让你来维护，但是不再兼容<strong>Django1.0和Django2.0</strong>的一些语法了。这时候就会碰到一个问题，我如何在我的电脑中同时拥有<strong>Django1.0和Django2.0</strong>两套环境呢？这时候我们就可以通过虚拟环境来解决这个问题。</p><h2 id="虚拟环境原理介绍"><a href="#虚拟环境原理介绍" class="headerlink" title="虚拟环境原理介绍"></a>虚拟环境原理介绍</h2><p>虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于<strong>Django1.0</strong>版本，又有一个项目是基于<strong>Django2.0</strong>的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装<strong>Django1.0和Django2.0</strong>来适配我们的项目。</p><h2 id="虚拟环境的使用"><a href="#虚拟环境的使用" class="headerlink" title="虚拟环境的使用"></a>虚拟环境的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>pip install virtualenv </p><p>pip3 install virtualenv </p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>virtualenv [虚拟环境的名称] </p><p>如果你当前的<strong>python3</strong>的查找路径在<strong>python2</strong>的前面，那么将会使用<strong>python3</strong>作为这个虚拟环境的解释器。如果<strong>python2</strong>在<strong>python3</strong>前面，那么将会使用<strong>python3</strong>来作为这个虚拟环境的解释器.</p><p><strong>创建虚拟环境的时候指定python解释器</strong></p><p>virtualenv -p “python安装路径” [虚拟环境名称] </p><h3 id="进入环境"><a href="#进入环境" class="headerlink" title="进入环境"></a>进入环境</h3><p>虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是Windows，第二种是*nix：</p><p>windows进入虚拟环境：进入到虚拟环境的Scripts文件夹中，然后执行activate。</p><p>*nix进入虚拟环境：source /path/to/virtualenv/bin/activate</p><p>一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。</p><h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><p>deactivate</p><h2 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><blockquote><p>linux:pip install virtualenvwrapper<br>windows: pip install virtualenvwrapper-win </p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>1.创建虚拟环境 mkvirtualenv [虚拟环境名称] 2.切换虚拟环境 workon [虚拟环境名称] 3.退出虚拟环境 deactivate 4.删除某个虚拟环境 rmvirtualenv [虚拟环境名称] 5.列出虚拟环境 lsvirtualenv </code></pre><h3 id="修改mkvirtualenv的默认路径"><a href="#修改mkvirtualenv的默认路径" class="headerlink" title="修改mkvirtualenv的默认路径"></a>修改mkvirtualenv的默认路径</h3><p>在我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量中添加一个参数WORKON_HOME，将这个参数的值设置为你需要的路径。</p><h3 id="创建虚拟环境的时候指定Python版本"><a href="#创建虚拟环境的时候指定Python版本" class="headerlink" title="创建虚拟环境的时候指定Python版本"></a>创建虚拟环境的时候指定Python版本</h3><p>在使用mkvirtualenv的时候，可以指定–python的参数来指定具体的python路径：</p><p>mkvirtualenv –python==C:\Python36\python.exe hy_env </p><h3 id="window配置环境变量"><a href="#window配置环境变量" class="headerlink" title="window配置环境变量"></a>window配置环境变量</h3><p>在环境变量里边添加 <strong>WORKON_HOME = “本地的目录”</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> virtualenv </tag>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解MySQL-InnoDB中索引与算法</title>
      <link href="2021/03/01/%E8%AF%A6%E8%A7%A3MySQL-InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>2021/03/01/%E8%AF%A6%E8%A7%A3MySQL-InnoDB%E4%B8%AD%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>索引在应用程序设计和开发中是一个重要的方面。往往实际开发中部分工程师对其重视或认知程度不足，忽略索引的重要性，导致要么不用索引，要么滥用索引，这样都会对系统性能产生影响。博主对索引这部分知识进行了总结和归纳，其中也附加自己的认知，分享给大家一起讨论和理解。</p><h2 id="为何用索引"><a href="#为何用索引" class="headerlink" title="为何用索引"></a>为何用索引</h2><p>大家仔细想想是不是大部分的系统<code>读</code>占比很大，而且在生产环境中，最容易出问题也是复杂的查询操作，这都是源自于一条条的<code>SQL</code>，SQL优化就成为重中之重，这其中索引起到非常关键作用。</p><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引在MySQL中也叫做<code>“键”或者&quot;key&quot;</code>（primary key，unique key，还有一个index key），是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。<br><strong>强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据</strong></p><h2 id="索引的认知"><a href="#索引的认知" class="headerlink" title="索引的认知"></a>索引的认知</h2><p>站在开发者的角度：<code>在系统设计之初就要考虑索引的设计</code></p><h1 id="认识索引"><a href="#认识索引" class="headerlink" title="认识索引"></a>认识索引</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><p>​索引的目的在于<code>提高查询效率</code>，结合生活中的案例，其实与查阅图书是一个道理：<code>先定位到章，然后定位到该章下的一个小节，然后找到页数</code>。相似的例子还有：查字典，查火车车次，飞机航班等。仔细思考，书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。你再想，你在没有数据的情况下先建索引或者说目录快，还是已经存在好多的数据了，然后再去建索引，哪个快，肯定是没有数据的时候快，因为如果已经有了很多数据了，你再去根据这些数据建索引，是不是要将数据全部遍历一遍，然后根据数据建立索引。你再想，索引建立好之后再添加数据快，还是没有索引的时候添加数据快，索引是用来干什么的，是用来加速查询的，那对你写入数据会有什么影响，肯定是慢一些了，因为你但凡加入一些新的数据，都需要把索引或者说书的目录重新做一个，所以索引虽然会加快查询，但是会降低写入的效率。</p><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><ul><li>在表中有大量数据的前提下，创建索引速度会很慢</li><li>在索引创建完毕后，对表的查询性能会大幅度提升，但是写性能会降低</li></ul><p><strong>本质：通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。</strong></p><p>数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p><h2 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h2><p>​前面提到了<code>访问磁盘</code>，那么这里先简单介绍一下<code>磁盘IO</code>和<code>预读</code>。磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<code>寻道时间</code>、<code>旋转延迟</code>、<code>传输时间</code>三个部分，<strong>寻道时间指的是磁臂移动到指定磁道所需要的时间</strong>，主流磁盘一般在5ms以下；<strong>旋转延迟就是我们经常听说的磁盘转速</strong>，比如一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了，还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；<strong>传输时间指的是从磁盘读出或将数据写入磁盘的时间</strong>，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。</p><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><p>在此之前我们先简单了解一下InnoDB存储引擎支持的索引，InnoDB存储引擎支持以下几种常见的索引：</p><ul><li>B+树索引</li><li>全文索引</li><li>哈希索引</li></ul><p>B+树索引是关系型数据库中查找最为常用和最为有效的索引。其中涉及很多的算法和数据结构，先认识一下相关的知识，这更加有助于我们理解B+树的工作方式。</p><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><p>也称其为<code>折半查找法</code>，前提是数据已经是有序的状态，将数据分割成两等份，再比较键值与中间值的大小，如果键值小于中间值，确定查找的数据在前半段，否则在后半段。通过一次次的比较，将查找区间缩小一半。时间复杂度为O(logn)。<br>代码实现：<a href="https://blog.csdn.net/qq_36581961/article/details/112203684">https://blog.csdn.net/qq_36581961/article/details/112203684</a></p><h2 id="二叉查找树、红黑树和平衡二叉树"><a href="#二叉查找树、红黑树和平衡二叉树" class="headerlink" title="二叉查找树、红黑树和平衡二叉树"></a>二叉查找树、红黑树和平衡二叉树</h2><p><strong>二叉查找树</strong>：<br>在二叉查找树中，左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，具体的实现过程可以参考<a href="https://www.cs.usfca.edu/~galles/visualization/BST.html">https://www.cs.usfca.edu/~galles/visualization/BST.html</a>。二叉查找树可以任意构造，当出现递增的情况，查找的次数回提高，和顺序查找差不多，类似于链表，这时查询效率降低。</p><p><strong>红黑树</strong>：<br>构建过程可以参考<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a>，在JDK1.8中HashMap底层使用就是红黑树，它的特点就是有<code>自旋</code>的功能，能够避免出现二叉查找树中递增的现象。但是当数据量过大时，会造成树的高度过高，也会降低查询效率。</p><p><strong>平衡二叉树</strong><br><code>定义：首先要符合二叉树的定义，其次必须满足任何节点的两个子树的高度最大差为1。</code>实现过程<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a>，平衡二叉树的查询速度很快，但是维护一棵平衡二叉树的代价是比较大的，因为需要大量的旋转操作。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><blockquote><p><strong>关于b+树的定义</strong>：B+树是为磁盘或其他直接存取辅助设备设计的一种<code>平衡查找树</code>，在B+树中，所有记录节点都是按键值的大小存放在同一层的叶子节点上，由个叶子节点指针进行连接。(这只是精简介绍，具体内容可以自行百度)</p></blockquote><p>​如图：<a href="https://coding-net-production-file-ci.codehub.cn/12c73320-1acb-11eb-ae87-97fbb992c8dd.png?sign=+YTZUdgyVbT160JiSrw7S15tnIZhPTEyNTcyNDI1OTkmaz1BS0lEYXk4M2xGbWFTNlk0TFRkek1WTzFTZFpPeUpTTk9ZcHImZT0xNjE0NDM1OTk4JnQ9MTYxNDIxOTk5OCZyPTY4OTk2NzEwJmY9LzEyYzczMzIwLTFhY2ItMTFlYi1hZTg3LTk3ZmJiOTkyYzhkZC5wbmcmYj1jb2RpbmctbmV0LXByb2R1Y3Rpb24tZmlsZQ==">点击查看图片</a>，是一颗b+树，最上层是树根，中间的是树枝，最下面是叶子节点。</p><p>如上图：浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容，一个块对应3个扇区，可以看到每个磁盘块包含几个数据项（深蓝色所示，一个磁盘块里面包含多少数据，一个深蓝色的块表示一个数据，其实不是数据，后面有解释）和指针（黄色所示，看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p><blockquote><p><strong>b+树的查找过程</strong>：如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。</p></blockquote><blockquote><p><strong>b+树性质</strong></p><ul><li><p>索引字段要尽量的小<br> ​通过上面的分析，我们知道IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有<strong>h=㏒(m+1)N</strong>，当数据量N一定的情况下，m越大，h越小；而<strong>m = 磁盘块的大小 / 数据项的大小</strong>，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p></li><li><p>索引的最左匹配特性<br>简单来说就是你的数据来了以后，从数据块的左边开始匹配，在匹配右边的，知道这句话就行啦~~~~，我们继续学下面的内容。当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p></li></ul></blockquote><h1 id="聚集索引和辅助索引"><a href="#聚集索引和辅助索引" class="headerlink" title="聚集索引和辅助索引"></a>聚集索引和辅助索引</h1><p>还记得MyISAM存储引擎在创建表的时候会在硬盘上生成哪些文件吗，是不是有三个<code>.frm.MYD.MYI</code>结尾的三个文件，<strong>frm结尾的是表结构，MYD结尾的是数据文件，MYI结尾的就是索引文件</strong>，也就是说索引也是存在硬盘上的，那InnoDB引擎呢，创建一个表，在硬盘上会生成<code>.frm.idb</code> 结尾的两个文件，那索引的呢，难道InnoDB就用不了索引吗？怎么可能？之前咱们有没有建立过索引啊，primary key、unique key是不是都叫做索引啊，但是索引那个文件去哪了呢，索引是不可能在表结构.frm（存什么字段什么类型这些东西）的文件中，那就只剩下<code>.idb</code>结尾的数据文件了，索引就在这里面，InnoDB引擎的表，它的<strong>索引和数据都在同一个文件里面</strong>，所以一直强调，使用InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据或者说方式。</p><p>也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。这种索引，我们就称为<code>聚集索引</code>，也就是在聚集数据组织数据的时候，就用这种索引。InnoDB这么做就是为了加速查询效率，因为你经常会遇到基于主键来查询数据的情况，并且通常我们把id字段作为主键，第一点是因为id占用的数据空间不大，第二点是你经常会用到id来查数据。如果你的表有两个字段，一个id一个name，id为主键，当你查询的时候如果where后面的条件是name=多少多少，那么你就没有用到主键给你带来的加速查询的效果（需要主键之外的辅助索引），如果你用where id=多少多少，就会按照我们刚才上面说的哪种树形结构来给你找寻数据了（当然不仅仅有这种树形结构的数据结构类型），能够快速的帮你定位到数据块。这种聚集索引的特点是它会以id字段作为依据，去建立树形结构，但是叶子节点存的是你表中的一条完整记录，一条完整的数据。记住这一点昂，<code>辅助索引</code>和这个内容有关系，会讲到一个<code>回表</code>的概念。</p><hr><p>​在数据库中，B+树的高度一般都在2-4层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，2-4次的IO意味着查询时间只需要0.02~0.04秒。</p><p>数据库中的B+树索引可以分为<strong>聚集索引</strong>（clustered index）和<strong>辅助索引</strong>（secondary index），聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，<strong>叶子结点存放着所有的数据</strong>。聚集索引与辅助索引不同的是：<strong>叶子结点存放的是否是一整行的信息</strong></p><h2 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h2><p>​InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。而<code>聚集索引</code>（clustered index）就是按照每张表的主键构造一棵B+树，同时<code>叶子结点存放的即为整张表的行记录数据</code>，也将聚集索引的叶子结点称为<code>数据页</code>。</p><p>聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。 如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为<code>聚簇索引</code>。如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有<code>六个字节</code>，而且是隐藏的，使其作为<code>聚簇索引</code>。 由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。</p><p><strong>聚集索引的优点</strong><br>它对主键的<code>排序查找</code>速度非常快，叶子节点的数据就是用户所要查询的数据。如用户需要查找一张表，查询最后的10位用户信息，由于B+树索引是双向链表，所以用户可以快速找到最后一个数据页，并取出10条记录；<code>范围查询</code>（range query），即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可</p><h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p>表中除了聚集索引外其他索引都是<code>辅助索引</code>（Secondary Index，也称为非聚集索引）（unique key啊、index key啊），与聚集索引的区别是：<strong>辅助索引的叶子节点不包含行记录的全部数据</strong>。</p><p>​叶子节点存放的是对应的那条数据的主键字段的值，除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark），其实这个书签你可以理解为是一个{‘name字段’，name的值，主键id值}的这么一个数据。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。如果我们<strong>select 后面要的是name</strong>，我们直接就可以在<strong>辅助索引的叶子节点找到对应的name值</strong>，比如：select name from tb1 where name=’xx’；这个xx值你直接就在辅助索引的叶子节点就能找到，这种我们也可以称为<code>[覆盖索引]</code>。如果你select后面的字段不是name，例如：select age from tb1 where name=’xx’；也就是说，我通过辅助索引的叶子节点不能直接拿到age的值，需要通过辅助索引的叶子节点中保存的主键id的值再去通过聚集索引来找到完整的一条记录，然后从这个记录里面拿出age的值，这种操作有时候也成为<code>[回表查询]</code>，就是从头再回去查一遍，这种的查询效率也很高，但是比覆盖索引低一些，再说一下昂，再辅助索引的叶子节点就能找到你想找的数据可称为[覆盖索引]。</p><h1 id="联合索引和索引覆盖"><a href="#联合索引和索引覆盖" class="headerlink" title="联合索引和索引覆盖"></a>联合索引和索引覆盖</h1><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>联合索引时指<strong>对表上的多个列合起来做一个索引</strong>，省的你查询的时候，where后面的条件字段一直再变，你就想给每个字段加索引的尴尬问题。联合索引的创建方法与单个索引的创建方法一样，不同之处在仅在于有多个索引列.</p><p><strong>注意建立联合索引的一个原则：</strong> 索引是有个<code>最左匹配的原则</code>的，所以建联合索引的时候，将区分度高的放在最左边，依次排下来，范围查询的条件尽可能的往后边放。</p><p><strong>联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理，</strong> 例如在很多情况下应用程序都需要查询某个用户的购物情况，并按照时间进行排序，最后取出最近三次的购买记录，这时使用联合索引可以帮我们避免多一次的排序操作，因为索引本身在叶子节点已经排序了</p><h2 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h2><p>InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。</p><p>使用覆盖索引的一个好处是：辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作</p><p><strong>注意：覆盖索引技术最早是在InnoDB Plugin中完成并实现，这意味着对于InnoDB版本小于1.0的，或者MySQL数据库版本为5.0以下的，InnoDB存储引擎不支持覆盖索引特性</strong></p><p>对于InnoDB存储引擎的辅助索引而言，由于其包含了主键信息，因此其叶子节点存放的数据为（primary key1，priamey key2，…,key1，key2，…）</p><h1 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">普通索引INDEX：加速查找 </span><br><span class="line">唯一索引：</span><br><span class="line">        -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复） </span><br><span class="line">        -唯一索引UNIQUE:加速查找+约束（不能重复） </span><br><span class="line">联合索引： </span><br><span class="line">-PRIMARY KEY(<span class="built_in">id</span>,name):联合主键索引 </span><br><span class="line">        -UNIQUE(<span class="built_in">id</span>,name):联合唯一索引 </span><br><span class="line">        -INDEX(<span class="built_in">id</span>,name):联合普通索引</span><br><span class="line">索引操作：</span><br><span class="line">添加主键索引:</span><br><span class="line">创建的时候添加:添加索引的时候要注意,给字段里面数据大小比较小的字段添加,给字段里面的数据区分度高的字段添加.</span><br><span class="line">聚集索引的添加方式</span><br><span class="line">创建的是添加</span><br><span class="line">        Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span> primary key,</span><br><span class="line">        )</span><br><span class="line">        Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span>,</span><br><span class="line">        Primary key(<span class="built_in">id</span>)</span><br><span class="line">        )</span><br><span class="line">表创建完了之后添加</span><br><span class="line">Alter table 表名 add primary key(<span class="built_in">id</span>)</span><br><span class="line">删除主键索引:</span><br><span class="line">Alter table 表名 drop primary key;</span><br><span class="line"></span><br><span class="line">唯一索引:</span><br><span class="line">        Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span> unique,</span><br><span class="line">        )</span><br><span class="line">            Create table t1(</span><br><span class="line">        Id <span class="built_in">int</span>,</span><br><span class="line">        Unique key uni_name (<span class="built_in">id</span>)</span><br><span class="line">        )</span><br><span class="line">表创建好之后添加唯一索引:</span><br><span class="line">alter table s1 add unique key  u_name(<span class="built_in">id</span>);</span><br><span class="line">    删除:</span><br><span class="line">    Alter table s1 drop index u_name;</span><br><span class="line">    </span><br><span class="line">普通索引:</span><br><span class="line">        创建:</span><br><span class="line">            Create table t1(</span><br><span class="line">            Id <span class="built_in">int</span>,</span><br><span class="line">            Index index_name(<span class="built_in">id</span>)</span><br><span class="line">            )</span><br><span class="line">            Alter table s1 add index index_name(<span class="built_in">id</span>);</span><br><span class="line">            Create index index_name on s1(<span class="built_in">id</span>);</span><br><span class="line">        删除:</span><br><span class="line">            Alter table s1 drop index u_name;</span><br><span class="line">            DROP INDEX 索引名 ON 表名字;</span><br><span class="line">举个例子来说，比如你在为某商场做一个会员卡的系统。 这个系统有一个会员表 有下列字段： </span><br><span class="line">会员编号 INT </span><br><span class="line">会员姓名 VARCHAR(<span class="number">10</span>) </span><br><span class="line">会员身份证号码 VARCHAR(<span class="number">18</span>) </span><br><span class="line">会员电话 VARCHAR(<span class="number">10</span>) </span><br><span class="line">会员住址 VARCHAR(<span class="number">50</span>) </span><br><span class="line">会员备注信息 TEXT</span><br><span class="line">那么这个 </span><br><span class="line">会员编号，作为主键，使用 PRIMARY </span><br><span class="line">会员姓名 如果要建索引的话，那么就是普通的 INDEX </span><br><span class="line">会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）</span><br><span class="line"><span class="comment">#除此之外还有全文索引，即FULLTEXT </span></span><br><span class="line">会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。 </span><br><span class="line">用于搜索很长一篇文章的时候，效果最好。 </span><br><span class="line">用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。 </span><br><span class="line">但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。 </span><br><span class="line"><span class="comment">#其他的如空间索引SPATIAL，了解即可，几乎不用</span></span><br></pre></td></tr></table></figure><h1 id="正确使用索引"><a href="#正确使用索引" class="headerlink" title="正确使用索引"></a>正确使用索引</h1><ul><li><p>范围问题，或者说条件不明确，条件中出现这些符号或关键字：**&gt;、&gt;=、&lt;、&lt;=、!= 、between…and…、like、大于号、小于号</p></li><li><p>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</p></li><li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p></li><li><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)</p></li><li><p>and/or</p><blockquote><p>#1、and与or的逻辑 条件1 and 条件2:所有条件都成立才算成立，但凡要有一个条件不成立则最终结果不成立 条件1 or 条件2:只要有一个条件成立则最终结果就成立 </p><p>#2、and的工作原理 条件： a = 10 and b = ‘xxx’ and c &gt; 3 and d =4 索引： 制作联合索引(d,a,b,c)<br>工作原理: #如果是你找的话，你会怎么找，是不是从左到右一个一个的比较啊，首先你不能确定a这个字段是不是有索引，即便是有索引，也不一定能确保命中索引了（所谓命中索引，就是应用上了索引），mysql不会这么笨的，看下面mysql是怎么找的： 索引的本质原理就是先不断的把查找范围缩小下来，然后再进行处理，对于连续多个and：mysql会按照联合索引，从左到右的顺序找一个区分度高的索引字段(这样便可以快速锁定很小的范围)，加速查询，即按照d—&gt;a-&gt;b-&gt;c的顺序 </p><p>#3、or的工作原理 条件： a = 10 or b = ‘xxx’ or c &gt; 3 or d =4 索引： 制作联合索引(d,a,b,c) 工作原理: 只要一个匹配成功就行，所以对于连续多个or：mysql会按照条件的顺序，从左到右依次判断，即a-&gt;b-&gt;c-&gt;d</p></blockquote></li><li><p>最左前缀匹配原则，非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p></li></ul><p><strong>其他情况</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- 使用函数</span><br><span class="line">   select * <span class="keyword">from</span> tb1 where reverse(email) = <span class="string">&#x27;egon&#x27;</span>;</span><br><span class="line">       </span><br><span class="line">- 类型不一致</span><br><span class="line">   如果列是字符串类型，传入条件是必须用引号引起来，不然...</span><br><span class="line">   select * <span class="keyword">from</span> tb1 where email = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#排序条件为索引，则select字段必须也是索引字段，否则无法命中</span></span><br><span class="line">- order by</span><br><span class="line">   select name <span class="keyword">from</span> s1 order by email desc;</span><br><span class="line">   当根据索引排序时候，select查询的字段如果不是索引，则速度仍然很慢</span><br><span class="line">   select email <span class="keyword">from</span> s1 order by email desc;</span><br><span class="line">   特别的：如果对主键排序，则还是速度很快：</span><br><span class="line">     select * <span class="keyword">from</span> tb1 order by nid desc;</span><br><span class="line"></span><br><span class="line">- 组合索引最左前缀</span><br><span class="line">   如果组合索引为：(name,email)</span><br><span class="line">   name <span class="keyword">and</span> email    -- 命中索引</span><br><span class="line">   name         -- 命中索引</span><br><span class="line">   email        -- 未命中索引</span><br><span class="line"></span><br><span class="line">- count(<span class="number">1</span>)或count(列)代替count(*)在mysql中没有差别了</span><br><span class="line"></span><br><span class="line">- create index xxxx on tb(title(<span class="number">19</span>)) <span class="comment">#text类型，必须制定长度</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><blockquote><p>避免使用select <em>-<br>count(1)或count(列) 代替 count(</em>)<br>创建表时尽量时 char 代替 varchar<br> 表的字段顺序固定长度的字段优先<br> 组合索引代替多个单列索引（经常使用多个条件查询时）<br> 尽量使用短索引<br> 使用连接（JOIN）来代替子查询(Sub-Queries)<br> 连表时注意条件类型需一致<br> 索引散列值（重复少）不适合建索引，例：性别不适合</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
